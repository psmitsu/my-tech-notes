# Содержание

- [Обзор Bash](#overview)
    - [Специальные Символы](#overview-special)
        - [Управляющие Символы](#overview-special-control)
        - [Экранирование](#overview-quoting)
        - [Библиотека Readline и Файл Inputrc](#overview-special-readline)
    - [Shеll-Expansion - Расширение Командной Строки](#overview-expansion)
        - [Brace Expansion](#overview-expansion-brace)
        - [Tilde Expansion](#overview-expansion-tilde)
        - [Parameter Substitution](#overview-expansion-parameter)
        - [Command Substitution](#overview-expansion-command)
        - [Arithmetic Expansion](#overview-expansion-arithmetic)
        - [Word Splitting](#overview-expansion-word)
        - [Globbing](#overview-expansion-globbing)
        - [Process Substitution](#overview-expansion-process)
    - [Перенаправления Ввода/Вывода](#overview-redirect)
        - [Синтаксис Перенаправлений](#overview-redirect-syntax)
        - [/dev/null и /dev/zero](#overview-redirect-dev)
        - [Here-документы](#overview-redirect-heredoc)
        - [Анонимные Каналы](#overview-redirect-pipe)
        - [Перенаправление Блоков. Блок {}](#overview-redirect-block)
    - [Bash-Скрипты](#overview-scripts)
    - [Subshell, Блок ()](#overview-subshell)
    - [Переменные](#overview-variables)
        - [Позиционные Параметры](#overview-variables-positional)
        - [Другие Встроенные Переменные](#overview-variables-builtin)
    - [Ветвления](#overview-branching)
        - [Exit-Статус и Команда Exit](#overview-branching-exit)
        - [And- и Or- Списки](#overview-branching-lists)
        - [If-then](#overview-branching-if)
        - [Тесты](#overview-branching-tests)
        - [Тестирующие Операторы](#overview-branching-testops)
        - [Case и Select](#overview-branching-case)
        - [Циклы](#overview-branching-loop)
    - [Функции](#overview-functions)
    - [Массивы](#overview-arrays)
    - [Builtins: Встроенные Команды](#overview-builtins)
        - [Ввод и Вывод](#overview-builtins-inout)
        - [Считывание Аргументов с Помощью getopts](#overview-builtins-getopts)
        - [Управление Процессами и Заданиями](#overview-builtins-jobs)
- [Пользовательские Команды](#usercmd)
    - [Справочные Команды](#usercmd-man)
    - [Базовые Команды](#usercmd-base)
    - [Команды Контроля Доступа](#usercmd-acl)
    - [Команды для Обработки Групп Файлов](#usercmd-group)
    - [Обработка текста](#usercmd-text)
        - [grep](#usercmd-text-grep)
        - [Sed](#usercmd-text-sed)
        - [awk](#usercmd-text-awk)
    - [Работа с Файлами](#usercmd-file)
        - [Работа с Бинарными Файлами](#usercmd-file-binary)
        - [Архивация](#usercmd-file-archive)
        - [Шифрование и Проверка Хэшэй](#usercmd-file-encrypt)
    - [Коммуникации](#usercmd-comm)
        - [OpenSSH](#usercmd-comm-ssh)
    - [Дата и Время](#usercmd-time)
    - [Терминалы](#usercmd-terminal)
    - [Разное](#usercmd-etc)
- [Системные и Административные Команды](#systemcmd)
    - [Статистика](#systemcmd-stat)
        - [Сетевая Статистика](#systemcmd-stat-net)
        - [Strace](#systemcmd-stat-strace)
        - [Journalctl](#systemcmd-stat-journalctl)
    - [Инициализация и Сервисы](#systemcmd-init)
    - [Процессы](#systemcmd-process)
    - [Модули Ядра](#systemcmd-module)
    - [Пользователи и Группы](#systemcmd-users)
    - [Файловая Система](#systemcmd-filesys)
        - [Монтирование](#systemcmd-filesys-mount)
        - [Создание Файловых Систем](#systemcmd-filesys-makefs)
        - [Работа с Блочными Устройствами](#systemcmd-filesys-block)
        - [Chroot](#systemcmd-filesys-chroot)
        - [Бэкап с Помощью LVM](#systemcmd-filesys-lvm)
    - [Сеть](#systemcmd-network)
        - [Iptables](#systemcmd-network-iptables)
    - [Разное](#systemcmd-etc)
- [Рецепты](#recipes)
    - [Администрирование Linux](#recipes-admin)
        - [Проверка и Настройка Сети](#recipes-admin-netconfig)
        - [Настройка Автоматического Монтирования](#recipes-admin-automount)
        - [LVM](#recipes-admin-lvm)
        - [Samba](#recipes-admin-samba)
        - [LAMP](#recipes-admin-lamp)
        - [Ручная Сборка Софта](#recipes-admin-build)
    - [Виртуализация](#recipes-virt)
        - [Контейнеры LXC](#recipes-virt-lxc)
        - [Qemu и KVM](#recipes-virt-qemu)
    - [Debian](#recipes-debian)
        - [Установка Debian 11](#recipes-debian-install)
        - [Менеджмент Пакетов с APT](#recipes-debian-apt)
    - [Графическое Окружение](#recipes-desktop)
        - [Wayland](#recipes-desktop-wayland)
        - [KDE](#recipes-desktop-kde)
        - [Gnome](#recipes-desktop-gnome)
    - [Linux на Специфичном Оборудовании](#recipes-devices)
        - [Mac](#recipes-devices-mac)
        - [Разные Устройства](#recipes-devices-etc)
    - [Пользовательские Приложения](#recipes-userapp)
        - [Web-Сёрфинг](#recipes-userapp-websurf)
        - [Запуск Программ для Windows с Помощью Wine](#recipes-userapp-wine)
        - [Работа с Документами](#recipes-userapp-doc)
        - [Обработка Видео](#recipes-userapp-video)
        - [Обработка Изображений](#recipes-userapp-image)
        - [Разное](#recipes-userapp-etc)
- [Разное о Linux](#etc)
    - [Структура Файловой Системы](#etc-filesystem)
    - [Общие Советы](#etc-advice)
    - [Cсылки](#etc-references)

<a name="overview"></a>
# Обзор Bash

Bash - командная оболочка Unix и язык команд. Оболочка по умолчанию для большинства Linux дистрибутивов.

Некоторые понятия:

- Метасимвол: пробел, табуляция, перенос строки, ‘|’, ‘&’, ‘;’, ‘(’, ‘)’, ‘<’, или ‘>’.
- Оператор: один или несколько метасимволов.
- Слово: последовательность любых символов, кроме неэкранированных метасимволов.

Как работает Bash, вкратце:

1. Считывает ввод из файла, из строки-аргумента к команде `bash -c`, или из терминала
1. Разбивает ввод на токены: слова и операторы
1. Парсит из токенов команды
1. Производит расширения командной строки
1. Производит перенаправления
1. Исполняет команды

<a name="overview-special"></a>
## Специальные Символы

- `#` - комментарий. Содержимое строки после него не будет выполняться.
- `;` - разделитель комманд. Позволяет поместить две команды в одной строке
- `\` - escape/экранирование – предотвращает интерпретацию следующего символа.

<a name="overview-special-control"></a>
### Управляющие Символы

Приводятся символы для режиме Emacs (см. ниже).

- `Ctrl+a` – перемещает курсор в начало строки
- `Ctrl+e` – в конец строки
- `Ctrl+f` – на один символ вперед (вправо)
- `Ctrl+b` – на один символ назад (влево)
- `Alt+f` – на одно слово вперед
- `Alt+b` – на одно слово назад

- `Ctrl+p` – предыдущая комманда из истории
- `Ctrl+n` – следующая комманда из истории
- `Alt+<` - начало истории
- `Alt+>` - конец истории
- `Alt+.` - предыдущий аргумент

- `Ctrl+k` - вырезать текст от курсора до конца строки
- `Alt+d` - вырезать текст от курсора до конца слова
- `Ctrl+y` - вставить текст с вершины kill-буффера
- `Alt+y` - повернуть kill-буфер и вставить текст с новой вершины

- `TAB` - выбрать следующее авто-дополнение
- `Alt+?` - показать все авто-дополнения

<a name="overview-quoting"></a>
### Экранирование

- `"any string"` – внутри строки в двойных кавычках не будут интерпретироваться никакие символы, кроме `$`, и `\`
- `'any string'` – внутри строки в одинарных кавычках не будут интерпретированы никакие символы
- `\a` – то же, что `'a'`. 
    -В аргументе некоторых команд имеет особое значение. Н-р, `\n` - символ новой строки в `echo` и `sed`.
- `$'any string'` - ANSI-C quoting. Символы экранированные `\` в этой строки интерпретируется так же, как в стандарте Ansi C.
    - Пример: `IFS=$' \t\n'`

<a name="overview-special-readline"></a>
### Библиотека READLINE и файл INPUTRC

Ввод текста внутри командной строки обеспечивается библиотекой readline. Ее можно настроить под разные стили редактирования. По умолчанию, readline интерпретирует пользовательский ввод в режиме emacs: редактирование текста практически соответствует работе в текстовом редакторе Emacs. Управляющие символы выше именно для этого режима.

Популярная альтернатива – режим редактирования vi. Аналогично режиму emacs, делает ввод команд близким к работе в текстовом редакторе Vi. Активировать режим можно, введя команду
`set -o vi` в терминале.

Конфигурация readline задается через файлы `/etc/inputrc` и `~/.inputrc`. Чтобы сменить режим редактирования по умолчанию в терминале и других програмах, использующих `readline`, нужно поместить в `~/.inputrc` следующую строку:

    set editing-mode vi

Документация:

    man readline

Важные секции: INITIALIZATION FILE, EDITING COMMANDS, DEFAULT KEY BINDINGS.

<a name="overview-expansion"></a>
## Shell Expansion - "Расширение" Командной Строки

После того, как коммандная строка разбивается на токены, Bash расширяет ее в несколько последовательных этапов:

1. brace expansion - расширение по фигурным скобкам
1. tilde expansion - расширение по тильде
1. parameter substitution - подстановка параметров
1. command substitution - подстановка команды
1. arithmetic expansion - арифметическое расширение
1. word splitting - разделение слов 
1. globbing - расширение имен файлов
1. process substitution - подстановка процесса

<a name="overview-expansion-brace"></a>
### Brace Expansion

    cp file1.{txt,backup} # cp file1.txt file2.backup
    echo {a..d}x{1..4} # Декартово произведение {a,b,c,d} и {1,2,3,4}

<a name="overview-expansion-tilde"></a>
### Tilde Expansion

Замена символа ~ на путь к домашней папке пользователя.

<a name="overview-expansion-parameter"></a>
### Parameter Substitution

- `${parameter:-default}` - подставит значение `default` если значение `parameter` не задано или равно `NULL`.
- `${parameter:=default}` - если значение `parameter` не задано или `NULL`, присвоит ему значение `default` и подставит.
- `${parameter:+alt_value}` - если значение `parameter` установлено, подставит вместо него `alt_value`
- `${parameter?err_msg}` - если значение `parameter` не установлено, Bash напечает сообщение об ошибке и уронит текущий процесс с exit-кодом 1.

- `${#string}` подставляет длину строки `string`
- `${string:position}` подставляет подстроку, начинающуся с позиции `position`
- `${string:position:length}` подставляет `length` символов, начиная с `position`
- `${string#substring}` проверяет начало строки на совпадение с паттерном `substring`, удаляет его из строки при совпадении. 
    - Удалит только первое совпадение.
    - Пример: `str=abcd; echo "${str#*b}"`  напишет `cd`. 
    - ${string##substring} - удалит все совпадения
- `${string%substring}` и `${string%%substring}` - аналогично предыдущему, удаляет паттерн с конца строки.
- `${string/substring/replacement}` - заменяет совпадение `string` с `substring` на `replacement`

<a name="overview-expansion-command"></a>
### Command Substitution

Выражения `$(command)` или ```command``` обозначают подстановку комманды. Bash запустит `command` в subshell-е и подставит вместо `$(command)` или ```command``` стандартный вывод выполненной команды.

    echo $( basename $0 ) # имя файла текущего скрипта

Заключив подстановку команды в двойные кавычки, мы предотвращаем globbing и разбивку результата на аргументы.

    ``echo a b`` # a: command not found
    "``echo a b``" # a b: command not found

Подстановка команд может быть вложенной (внутренние \` нужно экранировать с помощью \\).

<a name="overview-expansion-arithmetic"></a>
### Arithmetic Expansion

Выражения вида `(( expr ))` подвергаются арифметическому расширению. Арифметическое выражение, записанное внутри `(( ))`, будет вычислено; результат - подставлен вместо него.

`(( ))` поддерживает операторы `&&`, `||`, `&`, и `|`, инкремент/декремент, тернарный оператор и другие С-подобные конструкции.

Примеры:

    a=5; a=$(( a + 3 )) # a=8
    (( t = a < 45 ? 7 : 11 ))
    (( ++a )); (( a-- ))

Арифметическое расширение удобно использовать для перевода шестнадцатиричных чисел в десятичные.

    echo $(( 0xaf )) # 175

<a name="overview-expansion-word"></a>
### Word Splitting

Текст команды разбивается на слова, основываясь на разделителях указанных в в переменной $IFS. По умолчанию - пробел,табуляция,новая строка:
    
    printf $q "$IFS"
    # Выведет $' \t\n'

<a name="overview-expansion-globbing"></a>
### Globbing

Каждое слово проверяется на наличие символов `*`, `?`, и `[`. Эти символы обозначают, что слово является паттерном. Любой паттерн заменяется списком имен файлов, которые под него подходят.

Сопоставление с паттерном (Pattern Matching) происходит следующим образом.

- `*` совпадает с любой строкой, в т.ч. пустой
- `?` совпадает с одним (любым) символом
- `[...]` совпадает с одним из символов, заключенных в скобки. С помощью дефиса можно указать диапазон, н-р `[a-z]`
- `[:class:]` совпадает с символом, заданным конкретным class:

        alnum   alpha   ascii   blank   cntrl   digit   graph   lower print   punct   space   upper   word    xdigit

C помощью комманды `shopt -s extglob` можно включить составные паттерны. Паттерны внутри `()` перечисляются через `|`

- `?(pattern-list)` совпадает не более, чем с одним вхождением одного из паттернов
- `\*(pattern-list)` с любым количеством вхождений паттерна (в тч нулевым)
- `+(pattern-list)` с одним или более
- `@(pattern-list)` совпадает с одним из данных паттернов
- `!(pattern-list)` совпадает с чем угодно кроме указанных паттернов

Пример:

`ls \*.+(JPG|NEF)` - вывести названия файлов с расширением JPG и NEF

<a name="overview-expansion-process"></a>
### Process Substitution

Подстановка процеccа дает доступ к вводу/вывода процесса по имени файла.

    <(command) # заменяется на файл с выводом command
    >(command) # заменяется на файл с вводом для command

Пример:
    
    diff <(sort file1) <(sort file2)

Если нам нужен вывод stderr в подстановке процесса, нужно перенаправить stderr:

    <(command 2>&1)

<a name="overview-redirect"></a>
## Перенаправления Ввода/Вывода

<a name="overview-redirect-syntax"></a>
### Синтаксис Перенаправлений

Перед исполнением команды мы можем перенаправить ее ввод и вывод.

По конвенции, любой команде доступны 3 файла:

- stdin - стандартный ввод, имеет файловый дескриптор 0
- stdout - стандартный вывод, файловый дескриптор 1
- stderr - вывод ошибок, файловый дескриптор 2

Синтаксис перенаправлений:

- `n>filename` - вывод из файла под дескриптором n будет записываться в filename
    - старое содержимое файла стирается
    - `>filename` - то же, что `1>filename`, перенаправить стандартный вывод
    - `&>filename` - писать стандартный вывод и вывод ошибок в один файл
- `n>>filename` - вывод будет записываться в конец filename 
    - старое содержимое файла сохраняется
    - `>>filename` - то же, что `1>>filename`
    - `&>>filename` - писать стандартный вывод и вывод ошибок в конец filename
- `n<filename` - ввод из файла под дескриптором n будет считываться из filename
    - `<filename` - то же, что `0<filename`, перенаправить стандартный ввод
- `n>&m` - заменить дескриптор вывода m копией дескриптора n
    - Пример: `echoerr() { cat <<< "$@" 1>&2; }` - вывести текст в stderr
    - Пример: `ls -yz >> ls.log 2>&1` эквивалентно `ls -yz &>> ls.log`
    - `n>&-` - закрыть дескриптор n
- `n<&m` - заменить дескриптор ввода n копией дескриптора m
    - `n<&-` - закрыть дескриптор n

<a name="overview-redirect-dev"></a>
### /dev/null и /dev/zero

Если вывод команды нужно скрыть, его перенаправляют в файл `/dev/null`.

`/dev/zero` вывод из этого файла состоит из нуль-байтов. Используется н-р для инициализации файлов.

<a name="overview-redirect-heredoc"></a>
### Here-документы

Here-документ - вид перенаправления ввода. Команда, которой на ввод подали here-документ, будет в качестве стандартного ввода читать текст here-документа, пока не встретит строку с разделителем (в примере - слово `LimitString`). Here-документы обычно используются, когда нужно внутри скрипта ввести данные в интерактивную программу.

    cat <<LimitString
    line one
    line two
    LimitString

Внутри here-документа происходит расширение параметров, подстановка команды и арифметическое расширение. Пример:

    FOO="foo"
    ssh remote.host <<EOF
    FOO="bar"
    echo "$FOO" # foo
    echo "\$FOO" # bar
    EOF

Можно предотвратить расширения Bash внутри here-документа, обернув разделитель после << в кавычки.
    
    FOO="foo"
    cat <<'EOF'
    $FOO # $FOO
    EOF

Here-документ можно указать через оператор `<<-`. В этом случае из here-документа будут убрана табуляция в начале каждой строки. Используется при написании скриптов.

<a name="overview-redirect-pipe"></a>
### Анонимные Каналы

Вывод одной программы может быть направлен на ввод другой программы через механизм межпроцессной коммунникации под названием анонимный канал (Anonymous Pipe).
    
    program_outputs_a | program_reads_a

<a name="overview-redirect-block"></a>
### Перенаправление Блоков. Блок {}

Блоки кода (`while`, `until`, `for`, `if-then`) можно перенаправлять:

    while [ "$name" != "Smith" ]; do 
        read name
        let "count += 1" 
    done <"Names.txt"

    for i in {1..5}; do 
        echo "$i"
    done >/dev/null

    if [ "$TRUE" ]; then 
        read name
        echo "$name"
    fi <"Name.txt"

Можно задать блок кода с помощью `{ ... }`. Эта конструкция бывает полезна при перенаправлении:

    { printf 'Size: %d bytes\n' "$(wc -c < file.txt)"; cat file.txt; } > newfile.txt

<a name="overview-scripts"></a>
## Bash-Скрипты

Символы `#!` (shabang – шэбэнг) в начале текстового файла означают, что файл является скриптом. После шебанга указывается интерпретатор, которому будет подан на ввод этот файл. Примеры:
`#!/bin/bash`, `#!/bin/sed -f`, `#!/bin/python3`

Путь к файлу с шебангом Bash интерпретирует как вызов команды, указаной в шебанге, с данным файлом в качестве аргумента.

<a name="overview-subshell"></a>
## Subshell. Блок ()

Subshell это подпроцесс, запущенный Bash-ем. Запуск внешней программы (в т.ч. скрипта - в этом случае мы запускаем новый процесс Bash) порождает subshell. Встроенные команды (builtins) не запускают subshell. Subshell имеет область видимости отличную от родительской, хотя мы можем экспортировать родительские перменные с помощью команды `export`.

Subshell можно запустить вручную с помощью конструкции `( commands )`

    a=1; ( a=2; echo $a ); echo $a; # Выведет 2, затем 1; a=2 лишь внутри subshell-а

<a name="overview-variables"></a>
## Переменные

Bash позволяет сохранять текстовые значения в переменные. Если var1 – название переменной, то $var1 это получение ее значения: `var1=a; echo $var1` выведет a. Форма `$var1` – упрощение формы `${var1}`. Последнее сработает в ситуациях, где $var1 недостаточно определенно, например: `echo ${foo}bar`.

Переменная упоминается без $ в следующих случаях:

- Декларация
- Присвоение значения
- Удаление значения
- Экспорт
- Использование внутри арифметического выражения `((...))`
- Представление сигнала с помощью переменной

Переменные в Bash – символьные строки. В некоторых контекстах, Bash может трактовать значения переменных как числа.

<a name="overview-variables-positional"></a>
### Позиционные Параметры

Аргументы, переданные скрипту, хранятся во встроенных переменных, названных $0, $1, $2, … так, что число после $ соответствует позиции аргумента в командной строке. $0 – путь к скрипту, $1 – первый аргумент, и тд. Аргументы после $9 нужно упоминать в строгой форме, н-р ${10}.

Встроенная переменная $# хранит количество аргументов переданных текущему скрипту.
$* хранит строку с аргументами, записанными через пробел. $@ - как $*, но аргументы не интерпретируются и не раскрываются (bash expansion).

<a name="overview-variables-builtin"></a>
### Другие Встроенные Переменные

- `$HOME` – путь к домашней директории пользователя
- `$PWD` – путь к текущей директории
- `$PATH` – путь к исполняемым файлам
- `$LD_LIBRARY_PATH` – путь к динамическим библиотекам
- `$0` – путь к текущему скрипту (работает в любом shell-е, но не работает, когда скрипт подключен через `source script_name.sh`)
- `$BASH_SOURCE[0]` – путь к текущему скрипту.
    - Пример: получить путь к директории текущего скрипта:

            $(dirname "$(readlink -f "${BASH_SOURCE[0]}")")

- `$UID` – id текущего пользователя

    - Типичный пример - проверка на суперпользователя:

            if [ "\$UID" -ne 0 ]; 
                then echo "This script should be run as ROOT"; 
            fi

- `$RANDOM` – псевдорандомное число в диапазоне от 0 до 32767.
    - Пример: `echo $(( RANDOM % 2 ))` - 0 или 1.

Обзор всех встроенных переменных: `man bash /Shell Variables`

<a name="overview-branching"></a>
## Ветвления

<a name="overview-branching-exit"></a>
### Exit-Статус и Команда Exit

По завершении, любая программа в Linux возвращает интерпретатору определенное значение, называемое exit-статус. По конвенции, целочисленное значение 0 обозначает, что программа отработала корректно. Статус последней завершенной программы хранится в переменной $?.

Команда exit завершает bash-скрипт. Мы можем указать ей значение exit-статуса в качестве аргумента. Если мы указываем exit без аргумента или вообще не указываем, скрипт завершится, как если бы мы указали exit $?.

<a name="overview-branching-lists"></a>
### And- и Or- Списки

Список команд это последовательность команд, разделенных операторами `;`, `&&`, или `||`. Bash будет исполнять команды последовательности в порядке записи. Exit-статус последовательности – exit-статус последней выполненной команды. Когда команды разделены `;`, будут выполнены все команды. Когда команды разделены `&&`, они будут выполняться, пока exit-статус последней выполненной команды равен 0. Когда команды разделены `||`, они будут выполняться, пока exit-статус последней команды не равен 0.

<a name="overview-branching-if"></a>
### If-then

Конструкция `if-then` проверяет exit-статус списка команд и запускает другие команды, если exit-статус равен 0.

    if COMMANDS_A; then 
    	COMMANDS_B; 
    [elif COMMANDS_C; then 
    	COMMANDS_D;]
    [else 
    	COMMANDS_C;] 
    fi

Пустое тело для ветки можно сделать с помощью команды `:`, no-op

<a name="overview-branching-tests"></a>
### Тесты

Для различных проверок существует специальная команда `test`. Обычно используют ее синоним `[`.

    if [ 0 ]; then echo “0 is true”; fi
    if [ ]; then
    	echo “NULL is true”
    else
    	echo “NULL is false”
    fi

Комбинировать тесты можно с помощью and- и or- листов: н-р `[ … ] || [ … ]`.

Часто вывод комманд внутри теста перенаправляют в `/dev/null`:

    if grep Windows Notes.txt > /dev/null; then 
        rm Notes.txt; 
    fi

Bash 2.0+ предоставляет ключевое слово `[[ ... ]]`. Работает на меньшем количестве ОС, но удобнее test.

Внутри `[[ ]]` не происходит раскрытия имен, но есть раскрытие параметров и замена комманды.

`&&`, `||`, `<`, и `>` работают внутри `[[ ]]`. Так же разрешены вложенные выражения: `[[ (expr1) || (expr2) ]]`.

Конструкция `(( ... ))` вычисляет арифметические выражения в стиле С и возвращает exit-статус 1, когда это выражение равно 0, иначе возвращает 0. Поэтому используется в тестах, н-р:

    if (( 0 || 1 )); then echo "False or True = True"; fi

<a name="overview-branching-testops"></a>
### Тестирующие Операторы

Специальные операторы test позволяют проверять свойства файлов, н-р `[ -p /dev/fd/0 ]`

- `-e $f` - файл существует
- `-f $f` - обычный файл (т.е. не директория или устройство)
- `-s $f` - не пустой
- `-d $f` - директория
- `-b $f` - блок-устройство
- `-c $f` - символьное-устройство
- `-p $f` - пайп
- `-h $f` - символьная ссылка
- `-S $f` - сокет
- `-t $f` - терминал
- `-r $f` - предоставляет права на чтение 
    - аналогично, и `-w` и `-x`
- `-g $f` - имеет флаг set-group-id
- `-u $f` - имеет флаг setuid
- `-k $f` - имеет sticky bit
- `-O $f` - принадлежит текущему пользователю
- `-G $f` - принадлежит группе текущего пользователя
- `-N $f` - изменен с момента предыдущего чтения
- `$f1 -nt $f2` `f1` новее `f2`
- `$f1 -ot $f2` старше
- `$f1 -ef $f2` `f1` и `f2` оба являются жесткими ссылками на один и тот же файл

Операторы целочисленного сравнения. Пример: `[ "$a" -eq "$b" ]`

- `$a -eq $b` значения равны
- `$a -ne $b` не равны
- `$a -gt $b` a строго больше b
- `$a -ge $b` больше или равно
- `$a -lt $b` строго меньше
- `$a -le $b` меньше или равно

Операторы сравнения строк. Применение: `[ "$a" \< "$b" ]`, `[ -z "$str" ]`

- `$a = $b` строки равны
- `$a != $b` не равны
- `$a \< $b` строка слева лексиграфически больше. Нужно экранировать
- `$a \> $b` меньше. Нужно экранировать.
- `-z $a` пустая строка
- `-n $a` непустая строка

Логические операторы.

- `! expr`
- `expr1 -a expr2`
- `expr1 -o expr2`

<a name="overview-branching-case"></a>
### Case И Select

Конструкция `case` тестирует переменную на равенство многим значениям. В тестах работает Globbing.

    case "$variable" in
       "$pattern1" | "$pattern2" ... )
       COMMANDS
       ;;
       "$patternX" ) ... 
       ...
    esac

Пример:

    read -n1 keypress
    case "$keypress" in
        [[:lower:]] ) echo "Lowercase letter";;
        [[:upper:]] ) echo "Uppercase letter";;
        [0-9] )     ) echo "Digit";;
        *           ) echo "Punctuation or other";;
    esac

В Bash 4.0+, `case` может проваливаться (как `switch` без `break` в С):

    case $VAR in
    normal)
        echo "Эта ветка НЕ проваливается"
        ;;
    fallthrough)
        echo -n "Эта проваливается..."
        ;& # ;;& вместо :& продолжит проход case
    somethingelse)
        echo "...cюда"
        ;;
    esac

Конструкция `case` часто используется для построения меню. Для меню так же часто используется `select`. Эта конструкция будет показывать пользователю промт с текстом из переменной `PS3`. Текст, введённый пользователем, сохранится в переменную `$REPLY`.

    PS3='Choose your favourite vegetable'
    select veg in "beans" "carrots" "potatoes"
    do
        echo "Your favourite vegetable is $veg"
        break
    done

<a name="overview-branching-loop"></a>
### Циклы

Доступны следующие циклы:

- `for arg in LIST; do COMMANDS; done` - for-loop выполняет команды для каждого элемента списка
    - Список слов проходит расширение.
    - Пример: ``for w in {H,h}ello `ls`; do echo "$w"; done``
        - Выведет `Hello, hello`, и результат команды `ls`
- `while [ condition ]; do COMMANDS; done` - while-loop работает пока `condition` истинно
- `until [ condition ]; do COMMANDS; done` - until-loop работает пока `condition` ложно

Ключевые слова `continue` и `break` работают так же, как в C.

<a name="overview-functions"></a>
## Функции

Объявление функции:

    function fname () {
        commands
    }

Или просто
    
    fname () {
        commands
    }

Вызов функции:

    fname [ arg1 arg2 ... ]

Функция может принимать позиционные аргументы:
    
    foo () {
        if [ -n "$1" ]; then
            echo "$1"
        fi
    }
    
    foo bar # Выведет bar

В функции можно определять локальные перменные.

    a=1
    foo () {
        local a=2
    }
    echo $a # 1

Функция выдает exit-статус последней команды, которая была выполнена внутри функции. Функцию можно явно завершить комадной `return`. С помощью `return N` можно явно задать exit-статус `N`.

<a name="overview-arrays"></a>
## Массивы

Задание массива

    arr=() # пустой массив
    arr=( "Hello" "World" 123 )

Доступ к элементам массива

- `${arr[2]}` - третий элемент
- `arr[2]=6` - перезапись
- `${arr[@]}` - все элементы через пробел
- `${arr[@]:s:n}` - n элементов, начиная с s-го
- `${#arr[@]}` - количество элементов
- `${!arr[@]}` - индексы через пробел

Пример: проход по массиву

    for item in "${arr[@]}"; do
        echo "$item"
    done

Конкатенация массивов. Часто используется для добавления элемента в конец массива

    arr+=( 321 )

<a name="overview-builtins"></a>
## Builtins: Встроенные Команды

Список часто встречающихся команд

- `help` - показать информацию о встроенных командах
- `true`, `false` - выдать exit-статус 0 и 1 соответственно
- `type` - идентифицировать команду
    - Пример: `type ll` - выведет `ll is aliased to `ls -alF'`
 
- `cd` - сменить директорию на указанную в аргументе
- `pwd` - вывести текущую директорию
 
- `alias` - создать псевдоним для команды
    - Пример: `alias ll='ls -alF'`. Теперь команда `ll` эквивалентна `ls -alF`
    - Пример: `alias ll`. Раскрыть значение псевдонима `ll`.
    - Пример: `alias`. Без аргументов `alias` выведет все псевдонимы.
- `unalias` - удалить псевдоним.
    - Пример: `unalias ll`

- `export` - сделать переменную видимой для всех подоболочек
    - Пример: `export PATH="${mypath}/bin:$PATH"
- `declare`, `typeset` - указать свойства переменных
- `shift` - сместить позиционные параметры: $2 станет $1 и т.д.
- `unset` - удалить переменную

- `exec` - TODO
- `eval` - converts the string to a command
    - `eval echo $(echo \$HOME)` - выведет путь к домашней директории
        - `echo $(echo \$HOME)` - выведет строку "$HOME" без раскрытия

- `exit` - безусловное завершение скрипта
    - См. Ветвления
- `source` - исполнение команд из файла в текущей оболочке
    - Пример: `source ~/.bashrc` - применить настройки пользовательского конфига bash 
    - `.` эквивалентно `source`
- `shopt` - изменить опции bash "на лету"
    - Пример: `shopt -s extglob` - включить дополнительные паттерны
- `ulimit` - задать пределы для ресурсов доступных данной оболочке
    - Пример: `ulimit -f 1000` - задать максимальный размер файлов в 1ГБ

<a name="overview-builtins-inout"></a>
### Ввод и Вывод

- `echo` - напечатать аргумент в стандартный вывод
    - `echo -n` - Не завершать вывод новой строкой.
    - `echo "my text" 1>&2` - вывести в stderr

- `read` - читать стандартный ввод в указанную переменную, пока не встретится новая строка.
    - Пример: `read myvar`
    - `read` без аргументов считает ввод в переменную `REPLY`
    - `read -n1` считает один символ не дожидаясь новой строки
    - `read -d ' '` закончит ввод на пробеле вместо новой строки
        - `read -d ''` - считывание NUL произойдет когда в вводе не останется символов
    - `read -r` не будет экранировать символы обратными слэшами
    - `read -a` считает массив (по слову на индекс)
        - Пример: `IFS=$'\n' read -d '' -r -a lines < /etc/passwd`
            - Считает целые строки в массив $lines

- `printf` - упрощенный аналог printf из стандартной библиотеки С.
    - Пример: `printf "Pi с точностью до сотых: %1.2f" 3.1415926`
    - Строка формата переиспользуется, чтобы покрыть все аргументы:

            # Нужно привести путь к виду "/folder1/folder2/folder3"
            path=("$folder1", "$folder2", "$folder3");
            printf '/%s' "${parts[@]%/}"
 
<a name="overview-builtins-getops"></a>
### Считывание аргументов с помощью getopts

`getopts` - считать аргумент скрипта в переменную.

    while getopts ":abcde:fg" Option
    # getopts читает аргумент на позиции $OPTIND. 
    # $OPTIND инициализируется в 1 при старте скрипта. 
    # Каждый вызов getopts увеличивает $OPTIND на 1.
    # В примере прочитанный аргумент считывается в Option
    # ":abcde:fg" - OPTSTRING - ожидаемые флаги
    # Двоеточие : после e означает, что после e должен быть другой аргумент
    # Этот аргумент считается в $OPTARG
    do
      case $Option in
        a ) # обрабатываем опцию ...
        b ) # ...
        ...
        g ) # ...
      esac
    done
    # Сместим аргументы по количеству считанных.
    # На случай, если позиционные параметры будут обрабатываться где-то помимо getopts.
    shift $(($OPTIND - 1))

<a name="overview-builtins-getopts"></a>
### Управление Процессами и Заданиями

Оболочка может запускать программы асинхронно - в фоновом режиме. Процессы, порожденные таким образом, называются задания (jobs). Задания изначально привязаны к запустившей их оболочке - т.е. "умрут" вместе с ней.

- Оператор `&` - команда cmd запущенная как `cmd &` будет запущена в фоновом режиме.
- Управляющий символ `Ctrl+z` - остановить текущий процесс и отправить его в фоновый режим.
- `fg` - возобновить обычное исполнение остановленного процесса
- `bg` - возобновить исполнение процесса в фоновом режиме, как если бы он был запущен с оператором `&`

- `jobs` - вывести список заданий - процессов в фоновом режиме
    - Идентификаторы заданий можно использовать как аргументы к `fg` и `bg`

- `disown` - отделить от оболочки задание с jobid, указанном в аргументе disown.
    - `cmd & disown` - отделить программу немедленно

- `kill` - послать процессу сигнал. По умолчанию, посылает сигнал завершения работы.
    - Пример: `kill %1` - завершить задание с id 1
    - Пример: `kill -9 12345` Послать SIGKILL процессу 12345. Таким образом можно убить "зависший" процесс.

<a name="usercmd"></a>
# Пользовательские Команды

<a name="usercmd-man"></a>
## Справочные Команды

- `man` - читать руководство к программе
    - Пример: `man man`
    - `man N prog` - искать руководство в конкретном разделе
        - 1 - пользовательские команды
        - 2 - системные вызовы
        - 3 - функции библиотек C
        - 4 - специальные файлы
        - 5 - форматы файлов
        - 8 - команды администратора
    - У man-а навигация в стиле Vim, н-р поиск по `/`
        - Поиск опций: `/   --option` - три пробела после `/`
- `whatis` - краткое описание програмы
- `apropos` - искать ключевое слово в базе `whatis`
    - Пример: `apropos filesystem`
    - Пример: `apropos -s 3 hash` - искать слово "hash" в описаниях С-функций
    - Пример: `apropos -s 2 .` - вывести все описания системных вызовов
- `info`- браузер особого формата гипертекста
    - Много полезной документации распространяется в формате info
    - Навигация
        - стрелки - сдвинуть курсор на один символ
        - `M-f`, `M-b` - сдвинуть курсор на слово вперед/назад
        - `M-<`, `M->` - сдвинуть курсор в начало/конец ноды
        - `/text<CR>`, `?text<CR>` - поиск по регулярке вперед/назад
        - `<CR>` - перейти по гиперссылке
        - `n`, `p` - следующая/предыдущая нода
        - `u`, `l` - на ноду вверх, предыдущая нода
    - `info` - без аргументов откроет "директорию", список имеющихся info-документов
    - `info -w ls` - показать какой файл будет использован в качестве справки (man или info-doc)
    - В дистрибутивах, основанных на APT, для доступа к info-doc-у пакета `packagename` нужно устанавливать пакет `packagename-doc`
    - Эти пакеты имеют хорошую info-документацию: `libc`, `coreutils`, `bash`

-  Cжатая документация в `/usr/share/doc`
    - Много документации хранится в сжатом виде.
    - Читать можно с помощью `zcat`

<a name="usercmd-base"></a>
## Базовые Команды

- `ls` - показать листинг файла
    - `-R` рекурсивный древо-образный листинг директории
    - `-S` сортировка по размеру файла
    - `-t` сортировка по дате изменения
    - `-l` расширенный листинг
    - `-a` не игнорировать имена начинающиеся с `.`
- `cat, tac` - напечатать содержимое файла в стандартный вывод
    - `tac` - печать строк в обратном порядке
    - `-A` - печать скрытых символов
        - Unix-овый конец строки отпечается как $, Windows-овый как ^M$
    - `-n` - печать номеров строк
    - `-s` - сократить последовательные пустые строки в одну
    - Пример: `cat f1 f2 > f3` - соединить два файла в один
    - Пример: `cat diskimage.iso > /dev/sdС` - записать образ диска на флешку sdС
- `rev` - напечатать в обратном порядке символы каждой строки файла
- `cp` - скопировать файл
    - `-u` - обновление - не перезаписывать более новый файл при совпадении имен
    - `-a` - скопировать все дерево директорий
    - `-R src/. dest` - скопирует содержимое src, но не саму src. Важна точка в конце.
- `mv` - изменить директорию файла
- `rm` - удалить файл
    - `-r` удалить всё содержимое рекурсивно
    - Пример: `rm -- -badname` удалить файл с "плохим" именем "-badname"
- `mkdir` - создать директорию
    - `-p` - автоматически создать родительские директории
- `ln` - создать ссылку на файл
    - `-s` - создать символьную (мягкую) ссылку
    - Жёсткая ссылка это просто другое имя для файла
    - Мягкая ссылка может вести на файл в другой файловой системе

<a name="usercmd-acl"></a>
## Команды Контроля Доступа

- `chmod` - изменить права доступа к файлу
    - Пример: `chmod u+x ./myscript.sh` - добавить владельцу разрешение на исполнение файла
    - Вместо `u` можно указать `g` - группу, `o` - остальных, `a` - всех.
    - Вместо `x` можно указать следующие разрешения:
        - (r) read, (w) write, (x) execute - разрешает читать, изменять, исполнять файл / заходить в директорию
        - (s, задаётся u+s) setuid - заменяет эффективного пользователя собственником файла
        - (s, задаётся g+s) setgid - заменяет эффективную группу группой собственника
        - (t) sticky bit - запрещает кому-либо кроме владельца/рута удалять файлы
    - Так же можно задать права с помощью 4-х значной восьмеричной маски
        - Каждый бит которой определяет активен ли флаг на позиции этого бита
        - Флаги: `setUID,setGID,sticky,userRWX,groupRWX,otherRWX`
        - Можно опустить левую цифру, задавая только userRWX,groupRWX,otherRWX
            - Пример: `chmod 755 /some/path`

- `setfacl` - задать ACL - список контроля доступа
    - Позволяет задавать права доступа для разных пользователей/групп
    - Пример: `setfacl -m u:7000:x /my/path` 
    - Пример: `setfacl -m kenny:rw /my/path`
- `getfacl` - узнать ACL файла

<a name="usercmd-group"></a>
## Команды для Обработки Групп Файлов

- `find` - найти файлы и провести над ними операции
    - Типичный пример:

            # Удалить файлы в ./temp которые не изменялись уже 5 часов
            find ./temp -type f -atime +5 -exec rm {} \;

    - `find` принимает путь в качестве аргумента, последовательно обходит каждый файл внутри данного пути, выполняя над каждым действия, заданные "выражениями".
    - Каждый аргумент после пути является выражением. Выражения применяются к текущему файлу, комбинируются с помощью логических операторов.
        - `! expr` отрицание
        - `expr1 expr2` логическое и
        - `expr1 -o expr2` логическое или
        - `\( expr \)` форсировать порядок выполнения. Скобки нужно экранировать.
    - `print` - выражение по умолчанию
    - `-exec COMMAND` - применить комманду к текущему файлу. `COMMAND` должна оканчиваться `\;`. Внутри `COMMAND` на имя текущего файла можно сослаться с помощью `{}`. Выражение `-exec` истино если `COMMAND` возвращает 0.
        - Пример: расширение параметра в `find -exec`

                find . -name '*.rar' -exec bash -c 'unrar x "$1" /destdir/"${1%.rar}"' _ {} \;
                # -c заставляет Bash выполнить команду записаную в строке, идущей после -с
                # после строки с командой идут позиционные аргументы, начиная с $0 - "_"

    - Опции для фильтрации файлов по имени и типу
        - `-type $type` - файл имеет тип: `f` - обычный файл, `d` - директория, `l` - символьная ссылка
        - `-name` - имя файла соответствует паттерну. Можно использовать регулярные выражения.
            - Пример: `find ./ -name '*.cpp' -o -name '*.h'`
        - `-iname`
        - `-user $username` - файл принадлежит пользователю $username
        - `-maxdepth $levels` - файл в пределах $levels вложенных директорий ниже данной
            - Пример: `find ./ -maxdepth 0` - файлы в текущей директории
        - `-prune` - не спускаться в директорию
            - Пример: `find . -path ./src/plugin -prune -o print` - Игнорировать содержимое директории `./src/plugin`, напечатать остальные файлы.

    - Опции для фильтрации файлов по времени
        - `-mtime $nhours` - файл был модифицирован не ранее чем $nhours часов назад
        - `-ctime $nhours` - статус файла был изменен не ранее чем $nhours часов назад
            - статус файла может быть изменен н-р с помощью команды `chmod`
        - `-atime $nhours` - файл читался не ранее чем $nhrous часов назад
        - `-newer $otherFile` - файл был модифицирован ранее чем файл $otherFile
            - Пример:

                    touch -t 202103160120 timeref # файлу "timeref" выставлена дата 16 Мар 2021, 01:20
                    find ./ -newer timeref # ищем файлы измененные позднее, чем 16 Мар 2021, 01:20

        - `-newerXY $reference` - timestamp Х текущего файла больше чем timestamp Y файла $reference
            - `X` и `Y` могут принимать следующие значения:
                - `a` - дата последнего чтения
                - `B` - дата создания (Birth)
                - `m` - дата изменения содержимого
                - `c` - дата изменения статуса inode (н-р изменения прав доступа)
                - `t` - только для Y. $reference трактуется как прямое указание времени
                    - Время можно указывать в формате аргумента к команде `date -d`
                - Пример: `find ./ -newermt '15 seconds ago'`

- `xargs` - разбивает стандартный ввод на группы и применяет команду к каждой группе.
    - `echo` - команда по умолчанию.
    - `-L $maxlines` - преобразовывает каждые $maxlines вводных строк в одну
        - Пример: `ls | xargs -n 8` - напечатать файлы текущей директории в 8-ми столбцах
        - По умолчанию убирает из ввода все переносы строк, т.е. на выходе будет одна строка.
    - `-0` - разделяет ввод по 0-символу. 
        - В комбинации с `find -print0` или `grep -lZ` позволяет обрабатывать имена файлов с пробелами
        - Пример: `grep -rliwZ GUI / | xargs -0 rm -f` - удаляет все файлы содержащие текст "GUI"
    - `-P $nproc` - параллелизует задачу в $nproc процессов.

<a name="usercmd-text"></a>
## Обработка Текста

- `sort` - сортирует строки ввода
    - Пример: `sort names.txt`
    - Без аргумента сортирует стандартный ввод.
- `uniq` - удаляет дубликаты строк расположенные рядом. Часто используется в канале с sort
    - Пример: `sort strings-with-dupes.txt | uniq`
- `head`, `tail` - напечатает первые/последние 10 строк файла
    - Пример: `head -15 myfile` - первые 15 строк
    - Пример: `head -1 /dev/hdc` напечатает "кракозябры" если устройство доступно для чтения
    - Пример: `head -c $SIZE < /dev/zero > file` создаст файл размером $SIZE байт
- `cut` - извлечь поля из строк в файле
    - `-d` - разделитель. По умолчанию - TAB
    - `-f` - номера полей, которые нужно извлечь
    - Пример: `cut -d ' ' -f1,2 /etc/mtab` - первые два столбца из таблицы монтированных ФС

<a name="usercmd-text-grep"></a>
### grep

- `grep` - искать строки, в которых есть совпадения с заданным паттерном. Можно искать в файлах или в стандартном вводе.
    - `grep $pattern $file1 $file2 ...` - базовое использование. Без указания файлов - читать `stdin`
    - Часто используемые опции сопоставления паттерна
        - `-e` - искать паттерн. `-e pattern1 -e pattern2` - можно искать сразу несколько
        - `-i` - регистро-независимое сопоставление (case-**i**nsensitive)
        - `-v` - выдать строки где НЕТ совпадений с заданным паттерном
        - `-E` - интерпретировать заданный паттерн как обычное регулярное выражение
        - `-F` - быстрый поиск - не использовать регулярные выражения.
        - `-w` - искать только полные совпадения слов
    - Часто используемые опции вывода
        - `-c` - подсчитать количество совпадений
        - `-n` - печатать порядковый номер строки с совпадением
        - `-q` - убрать вывод. Нужно в тестах - `grep` возвращает exit-статус 0 при нахождении совпадений.
    - Часто используемые опции обхода файлов
        - `-a` - интерпретировать бинарный файл как текст
        - `-I` - не проверять бинарные файлы
        - `-r` - рекурсивный поиск без следования по символьным ссылкам.
        - `-R` - рекурсивный поиск со следованием по символьным ссылкам.
        - `-H` - печатать имя файла где найдены совпадения
        - `-l` - печатать только имена файлов, опустив строки где найдены совпадения
     - Пример: `find -name node_modules -prune -o -type f -exec grep -Hn {} \;`

<a name="usercmd-text-sed"></a>
### Sed

- `sed` - stream editor, редактор потока. Изменяет поток ввода строка за строкой
    - Может работать как с указанным файлом, так и со стандартным вводом.
    - Часто используемые команды
        - `[address-range] p` - напечатать указанный диапазон строк
        - `[address-range] d` - удалить указанный диапазон строк
        - `[address-range] s/a/b/[operator]` - заменить паттерн `a` паттерном `b`
            - Вместо `/` можно использовать любой другой символ, н-р `%` или `:`
            - По умолчанию удаляет первое совпадение в каждой строке
            - Оператор `g` в конце - удалить все совпадения
        - `[address] iTEXT` - вставить текст перед адресом
        - `[address] aTEXT` - вставить текст после адреса
    - `[address-range]` - диапазон строк, к которым будет применяться команда
        - Можно указать паттерн: `sed '/ABC/ d'` - удалить строки с ABC
        - Номер строки: `sed '8 p'` - напечатать 8-ую строку
        - Диапазон: `sed '1,/^$/ d'` - удалить строки от начальной до первой пустой
    - Паттерны в sed
        - Регулярные выражения в sed имеют специфичный синтаксис.
            - Пример: чтобы получить специальное значение `+`, нужно писать `\+`
            - Детали см. в `info sed`
        - В паттернах можно использовать классы символов POSIX.
    - Опция `-e`: когда нужно указать несколько команд, нужно указывать их через `-e`
        - Пример: `sed -e 's/macos/MacOS/g' -e 's/linux/Linux/g'`
    - `{}` - командный блок. Внутри него команды, перчисленные через `;` будут выполняться в порядке записи.
        - Пример: `sed '/[0-9A-Za-z]/,/^$/ {/^$/ d;}'` - удалить первую пустую строку из любой последовательности пустых строк.
    - 
            
<a name="usercmd-text-awk"></a>
### awk

- `awk` - скриптовый язык для обработки текста.
    - Сейчас awk не популярен. Его задачи обычно решают с помощью Python или Ruby.
    - Однако, в отличие от Python или Ruby, AWK есть на всеъ \*nix системах.
    - "The AWK Programming Language" Ахо, Кернигана и Вайнбергера - классическая книга которую многие рекомендуют как введение в CS.
    - Основы AWK
        - AWK разбивает каждую строку ввода на поля - последовательности символов, по умолчанию разделенные пробелами.
        - `{'CODE'}` - В Bash-е, блоки AWK-кода заключаются в строгие кавычки и фигурные скобки
        - Внутри блоков, можем обращаться к полю через `$1`, `$2`, ... `$0` - вся строка.
            - Пример. `echo one two | awk '{print $1} # one`
            - Пример. `echo one two | awk '{print $0}' # one two`
        - AWK может читать как стандартный ввод, так и файлы:
            - Пример. `awk '{print $0}' myfile.txt` - просто напечатает содержимое файла.
     - Примеры
        - Добавить переносы строки после каждой строки
            - `awk '{ print $0, "\n" }'`
        - Конвертировать текстовый файл из Unix формата в Windows и обратно
            - `awk '{ sub("$", "\r") }' unix.txt > windows.txt`
            - `awk '{ sub("\r$", ""); print }' windows.txt > unix.txt`

<a name="usercmd-file"></a>
## Работа с Файлами

- `less` - программа для чтения больших текстов в терминале.
    - Управляются в стиле vi
        - `q` - выход
        - `j`, `k` - прокрутка вниз/вверх
        - `/` - поиск текста
        - `n` и `N` - следующее/предыдущее совпадение поиска
        - `g` - в начало файла
        - `G` - в конец файла
    - Сохранить цвета в тексте при его чтении с помощью less:
        - Многие команды, `dmesg`, `ls`, `grep`, и др. имеют опцию `--color=always`
        - Чтобы less "понимал" цвета, нужен специальный флаг: `less -R`
        - Пример: `dmesg --color=always | less -R`

- `file` - узнать тип файла по заголовкам
- `which` - узнать путь к команде
- `whereis` - узнать путь к команде + путь к man-ам
- `whatis` - краткая информация о программе (похоже на `apropos`)
- `locate` - найти файлы по имени
    - Пример: `locate rtl8188ee` - поиск файла, на отсутствие которого пожаловался `dmesg`
    - `updatedb` - Обновляет базу данных, которую использует `locate`
- `readlink` - узнать куда указывает символьная ссылка
- `strings` - найти строки в бинарном файле
- `shred` - перезаписать файл определенными байтами

- `diff` - сравнить файлы строка за строкой
    - Возвращает exit-код 0 когда файлы идентичны, иначе - 1
    - Вывод `diff` можно использовать как патч
        - Пример: `diff -u old.c. new.c > patch`
        - В патче уже будет указан путь к измененному файлу
    - `diff -r folder1 folder2` - сравнить рекурсивно файлы в папках
        - `-qr` - вывести только имена различающихся файлов
    - `diff -w old new` - опция `-w` игнорирует все whitespace символы
        - `-b` - игнорирует изменения в количестве whitespace-
        - См. также `-E`, `-Z`, `-B`

- `patch` - актуализировать файл(ы) согласно патчу, сделанному `diff`
    - `-pN` - пропустить N префиксов в имени файла
        - Пример: `-p1` превратит `/a/b/c` в `a/b/c`
        - Пример: `-p2` превратит `/a/b/c` в `b/c`

- `basename` - напечатать имя файла без предшествующего пути
- `dirname` - напечатать путь к файлу без имени самого файла

- `stat` - детальная информация о файле: директории, связанные устройства и др.
- `du` - статистика использования дискового пространства файлами
    - Пример: `du -h --max-depth=1 | sort -rh`
        - `--max-depth=1` - не проваливаться в директории
        - `du -h | sort -rh` - вывести в удобочитаемом размере, отсортировать
    - Пример: `du --exclude=./relative/path/a` - исключить пути из поиска
    - Пример: `du -ch ./\*.mp4` - кумулятивный подсчёт в удобочитаемом формате
- `df` - показать ФС в которой находится файл и доступное в ней свободное место
    - `df -h` - в удобочитаемом формате

<a name="usercmd-file-binary"></a>
### Работа с Бинарными Файлами

- `size` - информация о сегментах исполняемого файла или архива

- `hexdump` - печатает содержимое файла / стандартный ввод в 16-тиричном формате (и в некоторых других).
    - `-C` - формат: смещение в hex, байты в hex, ascii-символы
    - `-c` - формат: смещение в hex, символы (метасимволы будут печататься через \)
    - `-Cc` - можно указать сразу два формата
    - Пример: `hexdump -C firmware.bin`

- `readelf` - детальная информация об бинарнике elf
    - `readelf -a elfbinary` - все заголовки
- `nm` - напечатать символы объектного файла

- `objdump` - печатает информацию об объектных файлах
    - Пример: `objdump -d /usr/bin/ls` - дизассемблировать бинарник `ls`
- `strip` - удалить отладочную информацию из исполняемого файла

- `ldd` - напечатать зависимости от динамических библиотек для заданного исполняемого файла.
    - Осторожно! Иногда `ldd` запускает файл.
    - Пример: `ldd -r -v cmd` - вывести всю информацию, в версиях библиотек
- `ltrace` - запустить команду, перехватывая и печатая вызовы библиотек
    - Пример: `ltrace -e dlopen cmd` - перехватывать динамическую загрузку
        - Полезно, если нужно узнать какие библиотеки пытается прочесть
    - `-s N` - Макс. размер печатаемых строк (32 по умолчанию).

<a name="usercmd-file-archive"></a>
### Архивация

- `tar` - утилита для работы с архивами
    - Архив - несколько файлов упакованных в один.
    - Опции
        - `-f` - указать файл-архив
        - `-x` - извлечь архив в текущую директорию
        - `-C /some/dir` - в комбинации с `-x` извлечь в указаную директорию
        - `-c` - создать архив
        - `-u` - обновить архив
        - `-t` - напечатать список содержимого архива
        - `-r` - добавить файлы к архиву
        - `-A` - объединить архивы
        - `--after-date=DATE` - добавлять только файлы старше DATE. Можно указать файл
        - Сжатие
            - `-z` - gzip-сжатие. Слабое сжатие, но можно использовать на машине с <32MB ОЗУ и на машинах, где не установлена поддержка сжатия xz.
            - `-j` - bzip2-сжатие. Коэффициент сжатия выше, чем gzip. Не популярна (в 2020).
            - `-J` - xz-сжатие. Высокий коэффициент сжатия.

- `gzip` - стандартная утилита GNU для сжатия
    - `gunzip` - декомпрессия. Эквивалетно `gzip -d`
    - `zcat` - декомпрессия в стандартный вывод
- `bzip2` - альтернативная утилия для сжатия
    - `bunzip` и `bzcat` - декомпрессия
- `lzma` - сжатие с высоким коэффициентом
    - `unlzma`, `lzcat` - декомпрессия
- `xz` - lzma2 - сжатие с высоким коэффициентом, обратно-совместимое с lzma
    - `unxz`, `xzcat` - декомпрессия
- `zip`, `unzip` - Сжатие в кроссплатформенный zip-архив
- `unarc`, `unarj`, `unrar` - распаковка `.arc`, `.arj`, и `.rar` архивов

<a name="usercmd-file-encrypt"></a>
### Проверка Хэшей и Шифрование

- `sum` - хэш файла по алгоритму BSD checksum. Legacy, не рекомендуется.
- `cksum` - хэш по алгоритму CRC checksum
- `md5sum` - хэш по алгоритму md5
- `sha1sum` - хэш по алгоритму sha-1
- В целях безопасности лучше использовать новые, не-скомпрометированные (2021) алгоритмы:
    - SHA-2: `sha224sum`, `sha256sum`, `sha512sum`
    - BLAKE2: `b2sum`
    - Пример: проверка целостности ISO образа с помощью sha512sum
    
            cd directory/with/isoimage
            sha512sum -c /path/to/sha512sum

- `openssl` - имплементация Secure Sockets Layer.
- `gpg` - инструмент шифрования и проверки подписей Open Pretty Good Privacy. Часто рекомендовано взамен openssl.
    - Пример: симметричное шифрование c паролем и расшифровка
        - `gpg --output mydoc.gpg --symmetric mydoc` 
        - `gpg --output mydoc --decrypt mydoc.gpg`
    - Пример: Расшифровка ассиметрично зашифрованного файла
        - TODO
    - См. GNU Privacy Handbook: https://www.gnupg.org/gph/en/manual/book1.html

<a name="usercmd-comm"></a>
## Коммуникации

- `dig` - поиск имени хоста в базе DNS
    - `-x` - поиск ip-адреса
- `traceroute` - трассировка маршрута пакета до определенного хоста
- `ping` - отправить ICMP ECHO\_REQUEST пакет на удаленную машину. Используется для проверки соединения.
- `finger` -

- `nmap` - сканирование сервера на наличие открытых портов, связанных с ними сервисов, и др.
    - Пример: `nmap -sN 192.168.1.0/24` - простой ping-поиск хостов в локальной сети

- `telnet` - работа по протоколу telnet
- `ftp` - утилита для передачи файлов по ftp
- `wget` - скачивание файлов с http/ftp сайтов
    - Частые опции
        - `-p` - скачать все файлы необходимые для просмотра веб-страницы
        - `-r` - скачать все ссылки рекурсивно
        - `-c` - возобновить прерванную загрузку

- nc - netcat, "мультитул" для работы с tcp и udp портами
    - Пример: выполнение http запроса

            printf "GET /index.html HTTP/1.0\r\nHost: info.cern.ch\r\n\r\n" | nc info.cern.ch 80

    - Пример: одноразовый веб-сервер, возвращающий содержимое файла

            { printf 'HTTP/1.0 200 OK\r\nContent-Length: %d\r\n\r\n' "$(wc -c < $myfile)"; cat $myfile; } | nc -l -p 8080

    - Пример: удаленный доступ к оболочке

            nc -l -p 45454 -e /bin/sh 
            # на другом компьютере
            nc $REMOTE_HOST 45454 
            ls -la # напечатает содержимое директории где был запущен первый netcat

<a name="usercmd-comm-ssh"></a>
### OpenSSH

- ssh - удаленная оболочка
    - Пример: `ssh daniil@192.168.1.12`

- rsync - синхронизировать файл
    - Пример: `rsync -Pavz --delete -e "ssh -l $username" 192.168.1.12:/home/media/music /home/media/music`
        - Привести /home/media/music к состоянию /home/media/music на удаленном компьютере 192.168.1.12
        - `-P` - комбинирует `--partial` и `--progress`
            - `--progress` - показывает прогресс в процентах
            - `--partial` - предотвращает удаление недозагруженных файлов при прерывании операции
                - `--append-verify` - возобновить передачу частично загруженного файла
        - `-a` - обойти содержимое рекурсивно
        - `-v` - выводить информацию об операции (больше информации: `-vv`, `-vvv`)
        - `-z` - сжимать данные для передачи по сети
        - `--delete` - удалять лишние на стороне полачетеля
        - `-e` - использовать определенную удаленную оболочку.
            - `ssh -l` - зайти под определенным пользователем

- scp - защищенная передача файлов по сети
    - В 2021 OpenSSH рекомендует rsync взамен scp

<a name="usercmd-time"></a>
## Дата и Время

- `touch` - обновить время последнего доступа к файлу. Создать файл.
    - Обновлять время полезно н-р при `cp -u`, чтобы отметить файлы которые не нужно обновлять
- `time` - время выполнения команды
    - Пример: `time ls -l`
- `sleep` - остановить выполнение задач на указанное время
    - `usleep` - то же самое, но время можно указать в микросекундах
- `at` - выполнить набор команд в указаное время
    - Команды читаются из файла или стандартного ввода
    - `atq` - вывести отложенные задания, `atrm` - удалить задание по номеру
    - Пример: `echo "shutdown" | at now + 2 hours`

- `date` - напечатать дату и время.
    - Пример: `date +%k:%M` - текущее время в формате ЧЧ:ММ
    - `date -d $datestring` - позволяет указать дату в формате Date String
        - Пример: `date -d 'tomorrow'`
        - Пример: `date -d '5 seconds ago'`
        - См. `info date`
- `zdump` - напечатать время в указанной временной зоне
    - Пример: `zdump Europe/Moscow`

- `timedatectl` - напечатать/задать системное время
    - Задание системного времени вручную: `timedatectl set-time "yyyy-MM-dd hh:mm:ss"`
- `hwclock` - напечатать/задать машинное время
    - `hwclock --systohc` - установить машинное время из системного
    - `hwclock --hctosys` - наоборот

<a name="usercmd-terminal"></a>
## Терминалы

- `tty` - название терминала в котором находится пользователь
- `stty` - вывести/изменить настройки терминала

- `screen` - Работа в несколько окон внутри одного терминала
    - Управление
        - `Ctrl+a ?` - справка
        - `Ctrl+a c` - создать новое окно
        - `Ctrl+a "` - список окон
        - `Ctrl+a k` - убить окно

        - `Ctrl+a S` - разделить текущий регион горизонтально
        - `Ctrl+a |` - разделить текущий регион вертикально
        - `Ctrl+a X` - закрыть текущий регион
        - `Ctrl+a TAB` - переключить фокус на следующий регион

        - `Ctrl+a d` - отправить текущуцию сессию в спящий режим
            - `screen -r` - возобновить сессию

    - Автодополнение по TAB может не работать по умолчанию.
        - Включить в файле конфигурации: `echo "defshell -bash" >> ~/.screenrc`

<a name="usercmd-etc"></a>
## Разное

- `yes` - постоянно пишет "y" с переносом строки.
    - `yes no` - будет писать "no"
    - Можно использовать в командах которые требуют пользовательский ввод
- `printenv` - напечатать все переменные среды установленные для текущего пользователя
- `tee` - перенаправить вывод, сохранив стандартный вывод
    - Пример: `echo a | tee a.txt` напишет "a" в консоль и в файл
    - Пример: перенаправление двух потоков: `mycmd > >(tee -a stdout.log) 2> >(tee -a stderr.log >&2)`
- `mkfifo` - создать именованный канал для передачи данных между процессами
    - Перенаправление с помощью `|` использует тот же механизм.
- `dd` - data duplicator - копирует файл с некоторыми преобразованиями
    - Основные опции:
        - `if=INFILE` - входной файл
        - `of=OUTFILE` - выходной файл
        - `bs=BLOCKSIZE - сколько Байт в одном блоке
        - `seek=BLOCKS` - сколько блоков отсчитать в выходном файле, прежде чем начать запись
        - `skip=BLOCKS` - сколько блоков отсчитать во входном файле, прежде чем начать чтение
        - `count=BLOCKS` - сколько блоков считывать/записывать
- `env` - запустить программу с заданными переменными среды
    - Пример. `env DISPLAY=foo.bar:1.0 xcalc`
    - В большинстве оболочек можно просто писать переменные перед командой
        - Пример: `DISPLAY=foo.bar:1.0 xcalc`
- `watch` - повторять команду.
    - `-n N` - повторять через N секунд. По умолчанию, команда повторяется каждые 2 секунды.
    - Пример: проследить прогресс копирования файла
        
            cp debian-netinst.iso /some/dir &
            watch -n 0.1 du -s /some/dir/debian-netinst.iso 

<a name="systemcmd"></a>
# Системные и Административные Команды

<a name="systemcmd-stat"></a>
## Статистика

### Статичная Информация

- `uname` - напечатать информацию о системе
    - `uname -a` - полная информация. Часто используемый вариант.
    - `uname -m` - архитектура процессора
- `arch` - напечатать архитектуру процессора (то же, что `uname- m`)
- `lsb_release` - напечатать информацию о дистрибутиве
    - `lsb_release -a` - полная информация. Часто используемый вариант.

- `lscpu` - информация о процессоре
- `nproc` - количество доступных процессоров

- `lshw` - детальная информация об оборудовании
    - Пример: `lshw -c memory`
- `dmidecode` - информация об оборудовании из таблиц dmi
- `lsdev` - список устройств
- `lsusb` - вывести информацию о usb-шинах и подключенных устройствах
- `lspci` - вывести информацию о шинах pci

### Информация о Текущей Работе ОС

- `uptime` - напечатать, как долго работает система
- `lastlog` - время последнего захода в систему для всех пользователей

- `dmesg` - напечатать сообщения из кольцевого буффера ядра.
    - Показывает используемые драйверы и другую низкоуровневную информацию.
    - Пример: после подключения USB-устройства dmesg покажет как ядро обработало это событие - н-р, к какому файлу было привязано устройство.
    - `dmesg -T` - показывает время в удобочитаемом формате

- `lsof` - список открытых файлов
    - Примеры: 
        - `lsof /dev` - открытые файлы внутри директории `/dev`
        - `lsof -u daniil -r 2` - показать файлы открытые конкретным пользователем 
        - `lsof -i -a -p $PID` - показать сетевые файлы, открытые процессом `$PID`
    - Часто используемые опции:
        - `-r 2` - повторять команду каждые 2 секунды
            - `-r "2 m%T"` - писать время в формате `strftime (3)`
        - `-i` - показать сокеты. Так же могут быть полезны следующие опции:
            - `-i@192.168.1.2` - показывать соединения для определенного хоста
            - `-i :8080` - показывать соединения для определенного порта
            - `-n` - не раскрывать DNS информацию
            - `-P` - не раскрывать порт
        - `+D /some/dir` - рекурсивно проверит все файлы в директории
            - Полезно для выяснения причин высокого IO wait
            - Эта операция требует много оперативной памяти
        - `-a` - логическое "И" для опций
        - `-p` - показывать информация только для определенного процеса
            - `p ^$PID` - скроет файлы для процесса $PID

- `top` - обновляемый список процессов с наибольшей нагрузкой на CPU
- `iostat` - утилизация CPU и I/O статистика устройств и разделов
- `iotop` - мониторинг активности ввода/вывода процессов

- `free` - cтатистика использования оперативной памяти
- `vmstat` - статистика виртуальной памяти

- `logger` - добавляет сообщение в системный лог `/var/log/messages`
- `logrotate` - управление логами - сжатие, ротация и др. Обычно происходит автоматически.

<a name="systemcmd-stat-net"></a>
### Сетевая Статистика

- `iftop` - обновляемый список интернет-соединений с наибольшим потреблением трафика
- `nethogs` - обновляемый список процессов с наибольшим потреблением сетевого трафика

- `ss` - статистика сокетов
    - Часто используемые опции:
        - `-t` - tcp-сокеты 
        - `-u` - udp-сокеты
        - `-w` - raw-сокеты
        - `-l` - показать сокеты в режиме ожидания
        - `-a` - показать все сокеты
        - `-n` - не раскрывать dns-информацию
        - `-o` - показать таймер сокета
        - `-p` - показать процесс который пользуется сокетом
    - Фильтры: `[ state STATE-FILTER ] [ EXPRESSION ]`
        - `STATE-FILTER`: 
            - стандартные состояния TCP - `established`, `syn-sent`, `listening` и т.д.
            - Дополнительные, н-р `connected` - все, кроме `listening` и `closed`
        - `EXPRESSION`:
            - `{dst|src} [=] HOST`, `{dport|sport} [OP] [FAMILY:]:PORT`
        - Пример: `ss -o state fin-wait-1 '( sport = :http or sport = :https )'`
            - Показать таймеры всех fin-wait-1 сокетов для нашего веб-сервера
    - Примеры
        - `ss` - вывести все соединения
        - `ss -tap` - все tcp-соединения и связаные процессы
        - `watch ss -nputw | grep 193.138.179.70` - отследить соединения с определенным IP
    - `ss` - замена `netstat`. Большинство команд `ss` эквиваленты таким же командам `netstat` 

- `tcpdump` - перехват сетевого трафика
    - `tcpdump -D` - вывести список доступных интерфейсов
    - `tcpdump -i eth0` - начать захват пакетов на указанном интерфейсе
        - По умолчанию выводятся только заголовки
    - Часто используемые опции:
        - Выводить содержимое пакетов:
            - `-A` - в ASCII
            - `-X` - в HEX. Пропускает при прослушке (но не при чтении) некоторые пакеты
        - `-v`, `-vv` - увеличить кол-во информации о пакетах
        - `-n` - не раскрывать DNS 
        - `-c N` - захватить только N пакетов
        - `-tttt` - расширенный формат вывода времени
    - Фильтры:
        - Пример: `tcpdump -n -i eth1 src 10.0.0.1 and dst port 80`
            - Показать пакеты идущие с определенного ip на определённый порт
        - `port` - пакеты поступающие на указанный порт
        - `host` - пакеты идущие на/от определенного хоста
        - `tcp`, `udp`, `icmp`, и т.д. - фильтрация по протоколу
        - `src`, `dst` - следующее выражение будет относиться только к источнику/пункту назначения
        - `and`, `or`, `not` - операторы логической комбинации фильтров
    - Вывод в файл
        - `tcpdump -w dump.pcap` - tcpdump запишет "сырое" содержимое пакетов в файл форматa pcap
        - `tcpdump -r dump.pcap` - прочитать pcap-файл (при чтении можно применять фильтры)
        - Файлы `pcap` можно читать и другими программами, н-р `wireshark`

<a name="systemcmd-stat-strace"></a>
### Strace

- `strace` - трассировка системных вызовов и сигналов.
    - С помощью `strace` часто проверяют, почему не запускается некая программа.
        - Например, она не может открыть определенные файлы или библиотеки.
        - Так же см. программу `ltrace`, которая отслеживает обращения к библиотекам
    - Примеры
        - `strace -e trace=open,close,read,write,connect,accept mycmd` 
            - отслеживать перечисленные системные вызовы для команды `mycmd`.
        - `strace -qcf mycmd` 
            - `-c-`- напечатать суммарную информацию о совершенных системных вызовах
            - `-f` - следовать за порожденными процессами
            - `-q` - минимизировать сообщения
        - Пример: Программа `mycmd` зависла.
            1. `pgrep mycmd` 
                - находим номер процесса. Пусть это будет 22222
            1. `strace -p 22222` 
                - подключаем `strace` к процессу `mycmd`
                - Видим сообщения `flock(3, ...)` - файл под дескриптором 3 заблокирован.
            1. `lsof | grep "$( readlink /proc/22222/fd/3 )"` 
                - смотрим какой процесс получил блокировку над файлом.
     - Часто используемые опции
        - `-e recvfrom` - следить только за системным вызовом `recvfrom`
        - `-e trace=%file` - следить только за вызовами которые обращаются к файловой системе
        - `-e trace=%net` - следить только за вызовами связанными с сетью
        - `-e trace=%desc` - следить за вызовами которые работают с файловыми дескрипторами
        - `-z` - печатать только удавшиеся вызовы
        - `-Z` - печатать только неудавшиеся вызовы
        - `-e read=DESC -e write=DESC` - обозначить дескриптор за вводом/выводом которого нужно следить
        - `-y` - раскрывать файловые дескрипторы
            - `-yy` - дополнительная информация о дескрипторах, например адрес назначения сокета.
        - `-t`, `-tt` - печатать время
        - `-T` - время между началом и завершением каждого вызова
            - Можно использовать, например, для оценки задержек при доступе в сеть
        - `-c`, `-C`, `-w`, `-U` - суммарная информация о времени и количестве совершенных вызовов
        - `-p PID` - подсоединиться к работающему процессу
        - `-f` - следовать за порожденными процессами

<a name="systemcmd-stat-journalctl"></a>
### Journalctl

- `journalctl` - показать выборку из журнала systemd
    - `-b` - сообщения начиная с последней загрузки 
    - `-b <id>` - для указанной загрузки 
        - `--list-boots` - список загрузок, для которых велся журнал
        - Для этой опции необходимо указать `Storage=persistent` в `/etc/systemd/journald.conf`
    - `--since $date` - начиная с определенной даты. Поддерживает date string (н-р `--since yesterday`)
    - `--until $date` - до определенной даты. Поддерживает date string 

    - `-u $UNIT` - для определенного модуля systemd
        - Пример: `journalctl -y nginx.service -u php-fpm.service`
    - `_PID=$PID` -  для указанного процесса
    - `_UID=$UID` - для указанного пользователя 
    - `_GID=$GID` - для указанной группы 
    - `-F _PID` - показать все процессы, которые вели журнал.
        - `man systemd.journal-fields` - список всех полей, по которым можно отфильтровать сообщения
    - `journalctl /usr/bin/docker` - в качестве аргумента пути можно указать исполняемый файл, скрипт, или устройство.
    - `-k` - журнал сообщений ядра. Аналог `dmesg` 

    - `-p $log_level` - уровень журналирования
        - От 0 (emergency) до 7 (debug)
        - `man 3 syslog` - перечень уровней
    - `-n 20` -  последние 20 событий
    - `-f` - следить за журналом в реальном времени 

    - `--no-pager` - не использовать `less` для вывода
        - Используется для последующей обработки текста
    - `-o json` - выводить в формате `json` 

    - `--disk-usage` - сколько места занимает журнал
    - `--vacuum-size=1G` - задать максимум, после которого журнал будет уходить в ротацию 
    - `--vacuum-time=1years` - задать время, в течение которого будет храниться  журнал

<a name="systemcmd-init"></a>
## Инициализация и Сервисы

### Краткое Описание Процесса Инициализации

- Прошивка (Firmware) Материнской Платы
    - Инициализирует контроллеры и устройства, определяет диски
    - Bios
        - Загружает MBR диска, первого в порядке загрузки
        - Код в MBR запускает загрузчик
    - UEFI
        - Ищет на дисках ESP - системный раздел EFI
            - ESP содержит загрузчики и UEFI shell
        - Запускает желаемый загрузчик с ESP
        - В legacy BIOS режиме попытается загрузить MBR диска
- Загрузчик
    - Запускает c диска промежуточный загрузчик или ядро
    - GRUB - наиболее популярный загрузчик, используемый с Linux 
        - Cм. `info grub`
        - `/boot/grub2/grub.cfg` - рабочий конфиг. Он может переписываться автоматически, поэтому редактируем `/etc/default/grub`.
            - Генерировать рабочий конфиг нужно скриптом `grub-mkconfig`, скрипт `update-grub` вызывает его и автоматически заменяет рабочий конфиг
- Ядро Операционной Системы
    - Загружает корневой раздел файловой системы и первую программу - `init`
    - В некоторых случаях предварительно загружает initramfs
    - Процесс работы ядра с самого старта можно наблюдать в логе `dmesg`
- Initramfs
    - В некоторых случаях (н-р несколько файловых систем) загрузить сразу весь корневой раздел проблематично
    - Initramfs, расположенная в оперативной памяти, содержит минимум инструментов для того, чтобы смонтировать настоящий корневой раздел
- Init
    - Первая программа запущенная ядром
    - Порождает все остальные процессы
    - System V - классическая система инициализии
        - Предполагает наличие нескольких уровней работы ОС (runlevels)
            - Уровень 0 соответствует выключению компьютера
            - Уровень 1 соответстует режиму отладки, только базовые возможности ОС активны
            - Уровень 2 соответстует нормальному режиму работы, с доступом к сети, графическому интерфейсу и тд.
            - Уровень 6 соответствует перезагрузке (похож на уровень 0)
            - Так же могут быть другие уровни, н-р уровни 3-5 могут вносить небольшие изменения в уровень 2
        - `/etc/init.d/rc N` - активирует уровень N: запускает скрипты из директории `/etc/rcN`
            - Эти скрипты контролируют работу различных сервисов, н-р ssh демона, дисплейнего менеджера, и тд.
            - Скрипты, название которых начинается с S, обозначают старт сервиса, c K - завершение
            - Последующие (обязательные) две цифры исторически обозначали порядок запуска. 
                - Позднее порядок стал определяться автоматически исходя из зависимостей
            - Эти скрипты содержат наглядные примеры использования многих команд, рассмотренных в этом разделе
            - В некоторых системах вместо директории `/etc/init.d` используется `/etc/rc.d`
        - При загрузке системы, SysV запускает несколько процессов, руководствуясь файлом `/etc/inittab`:
            1. `/etc/init.d/rcS` - скрипт исполняющий все программы из `/etc/rcS.d/`:
                1. Конфигурация консольного ввода
                1. Загрузка драйверов
                    - Большинство модулей ядра подгружаются самим ядром при обнаружении устройств
                    - Другие загружаются если указаны в `/etc/modules`
                1. Проверка целостности файловых систем
                1. Монтирование локальных разделов
                1. Конфигурация сети
                1. Монтирование сетевых разделов
            1. `/etc/init.d/rc 2` - запуск уровня по умолчанию (обычно это уровень 2) 
                - Обычно первыми стартуют rsyslog, portmap, затем стандартные сервисы и наконец графика (н-р gdm)
            1. `getty` - наконец, init запускает виртуальные консоли
    - Systemd - система инициализации и системный менеджер
        - К концу 2010-х большинство популярных дистрибутивов используют Systemd
        - Противникам Systemd не нравится то, что он значительно больше и сложнее, чем просто система инициализации
        - Systemd контролирует работу всей ОС, храня информацию о различных компонентах - сервисах, устройствах и тд - в "юнит-файлах".
            - Юнит-файлы хранятся в `/lib/systemd/system` и `/etc/systemd/system`
                - Также Systemd генерирует временные юниты, которые распологаются в `/run/systemd/generator`
            - В рамках загрузки системы особенно интересны два вида юнитов: сервис (`.service` файл) и цель (`.target` файл)
                - Сервис-юнит описывает интерфейс, завимимости сервиса, в каких таргетах он должен включаться
                    - Близок в SystemV сервису
                - Target-юнит описывает состояние ОС, при котором активен определенный набор сервисов.
                    - Близок к SystemV уровню
        - В качестве инит-системы SystemD монтирует необходимые ФС, сервисы и драйверы
            - Этот процесс разбит на шаги, описываемые target-юнитами. См. `man 7 bootup`
            - Одним из первых шагов systemd конвертирует `/etc/fstab` в `.mount` юниты с помощью `systemd-fstab-generator`, и монтирует нужные разделы
            - Через симлинк `default.target` systemd определяет нужный таргет (обычно `graphical.target`) и запускает нужные сервисы

### Связанные Команды

- SystemV
    - `init` - процесс 1, система инициализации
    - `telinit` - симлинк на `init`
        - Для ручного изменения runlevel-а принято использовать `telinit`
    - `runlevel` - показать текущий уровень работы системы
    - `shutdown`, `reboot` - выключение/перезагрузка системы
    - Сервисы
        - `service --status-all` - вывести статус всех сервисов
            - `ls /etc/init.d` - вывести список всех сервисов
        - `service servicename start` - запустить сервис
            - `stop` - остановить сервис
            - `reload` - перезагрузить конфиги
            - `restart` - stop+start
            - `status` - текущий статус сервиса
        - `/etc/init.d/servicename <cmd>` - можно запускать команды выше так
        - `update-rc.d servicename defaults` - добавить сервис в runlevel по умолчанию
            - `update-rc.d servicename enable` - в некоторых случаях, см. `man update-rc.d`
        - `update-rc.d -f servicename remove` - удалить
- Systemd
    - Все команды SystemV автоматически транслируются в аналоги Systemd
    - `systemctl list-units` - вывести список юнитов
        - `systemctl list-units --type target` - активные таргеты
    - Сервисы
        - `systemctl list-unit-files --type service` - доступные сервисы
        - `systemtctl status` - вывести статус всех сервисов
        - `systemctl start servicename.service` - запустить сервис
            - `stop`, `reload`, `restart`, `status` аналогичны SysV
        - `systemctl enable servicename.service` - включать сервис при каждой загрузке
            - `systemctl disable servicename.service` - не включать
    - Также см. обзор [Journalctl](#systemcmd-stat-journalctl)
- OpenRС
    - Совместимая с SystemV система инициализации, популярная в Gentoo
    - Сервисы
        - `rc-service <cmd>` - стандартные команды сервису (`start`, `stop`, и т.д.) можно давать так
            - `/etc/init.d/servicename <cmd>` - можно давать как в SystemV
        - `rc-status` - показать активные сервисы
        - `rc-update -v show` - показать все доступные сервисы
            - `ls /etc/init.d` - альтернатива
        - `rc-update add servicname runlevel` - включать сервис при загрузке
        - `rc-update del servicname runlevel` - не включать

<a name="systemcmd-process"></a>
## Процессы

- `ps` - показать статистику процессов
    - `ps aux` - типичное использование
        - `a` - показывать процессы всех пользователей
        - `u` - показывать пользователя, которому принадлежит процесс
        - `x` - показывать любые процессы, не только прикрепленные к терминалу
- `pgrep`, `pkill` - комбинирует `ps` с `pgrep` или `pkill`
    - Пример: `pkill firefox` - найти и убить firefox
- `pstree` - вывести текущие процессы в древовидном формате
- `nice` - запустить процесс в фоновом режиме с заданным приоритетом исполнения
    - Пример: `nice -n 19 heavyprogram` - запустить ресурсоемкую программу `heavyprogram` с минимальным (19) приоритетом
    - См. так же `renice`
- `nohup` - запустить команду так, что она не умрет в момент, когда запустивший ее пользователь завершит сессию
- `pidof` - получить PID задания (н-р для `kill` или `renice`)
- `cron` - управление отложенным запуском программ.
    - Является процессом-демоном. Запускает программы указанные в `/etc/crontab`

<a name="systemcmd-module"></a>
## Модули Ядра

- Информация о модулях
    - `lsmod` - вывести загруженные модули ядра
    - `lspci -k` - вывести драйверы pci-устройств
    - `modinfo` - вывести информацию о модуле
- Загрузка/выгрузка модулей
    - `modprobe` - загрузить/выгрузить модуль ядра
        - В отличиe от `insmod` и `rmmod`, `modprobe` проверяет зависимости модулей
    - `insmod` - форсировать загрузку модуля ядра
    - `rmmod` - форсировать выгрузку модуля ядра

<a name="systemcmd-users"></a>
## Пользователи и Группы

- `users` - показать всех активных пользователей 
- `groups` - показать группы текущего пользователя
- `chown`, `chgroup` - изменить принадлежность файла пользователю/группе
- `useradd`, `userdel` - добавить/удалить пользователя
    - Пример: `useradd -m daniil` - добавить пользователя вместе с домашней директорией
- `usermod` - изменить пользователя (н-р поменять пароль, принадлежность к группам, и т.д.)
    - Пример: `usermod -l daniil ubuntu` - поменять имя пользователя ubuntu на daniil
        - Так же необходимо желательно изменить имя группы
    - Пример: `usermod -d /home/newHome -m daniil` - присвоить новую home-директорию пользователю 
        - `-m` - переместит содержимое старой домашней директории в новую
- `groupmod` - изменить группу (н-р имя, идентификатор, и т.д.)
    - Пример: `groupmod -n daniil ubuntu` - поменять имя группы ubuntu на daniil
- `passwd` - управлять паролем пользователя
    - Пример: `passwd daniil` - задать пароль для пользователя daniil
- `id` - показать действительный и эффективный идентификаторы пользователя и группы
    - Некоторые программы (н-р `su`) требуют root-доступ для работы. Такие программы имеют флаг доступа "setuid". 
    - Когда пользователь запускает подобную программу, его эффективный идентифактор - идентификатор суперпользователя.
- `who` - показать всех активных пользователей
    - `who -m` - показать информацию о текущем пользователе
- `w` - показать активных пользователей и запущенные ими процессы
- `su` - подменить пользователя
    - `su username` - стать пользователем "username"
    - `su` - без аргументов - стать суперпользователем
- `sudo` - запустить команду от лица суперпользователя
- `last` - показать последние входы в систему

<a name="systemcmd-filesys"></a>
## Файловая Система

<a name="systemcmd-filesys-mount"></a>
### Монтирование

- `mount` - монтировать файловую систему
    - Связанные файлы
        - `/etc/mtab` - список монтированных фс и разделов
        - `/etc/fstab` - список файловых систем которые монтируются автоматически
            - См. `man 5 fstab`
    - Пример: `mount -t iso9660 /dev/cdrom /mnt/cdrom` - монтировать диск
        - Если не указывать опцию `-t`, `mount` попробует угадать тип файловой системы с помощью `blkidlib`
    - Пример: `mount -r -t iso9660 -o loop image.iso /mnt/iso` - монтировать iso-образ
        - `-r` - read-only, только для чтения
        - `-o loop` - эквивалетно `losetup /dev/loop0`, см. `losetup`
    - Пример: `mount --bind old new` - смонтировать часть файловой системы где-то еще
        - Бинд-монтирование часто используется в контейнерах и jail-ах
        - `mount -o bind,ro src trgt` - бинд-монтирование в режиме только для чтения
            - Такая конструкция возможна лишь начиная с `util-linux` версии 2.27. В более ранних версиях:

                    mount --bind src trgt
                    mount -o remount,bind,ro src trgt

- `umount` - отмонтировать файловую систему
    - Производится перед извлечением связанного устройства, чтобы избежать потери записанных данных
    - `mount -R /mount/point` - отмонтировать директорию и все вложенные директории рекурсивно

- `sync` - записать данные из буфферов на устройства
    - На 2020-й год, вручную используется редко

- `findmnt` - вывести список всех смонтированных файловых систем
- `df /some/path` - показать к какой файловой системе относится файл

- `losetup` - установить loop-устройство
    - loop-устройство, н-р /dev/loop0, позволяет образаться к обычному файлу как к блочному устройству
    - `losetup -d <device-name>` - отвязать файл от loop-устройства

<a name="systemcmd-filesys-makefs"></a>
### Создание Файловых Систем

- `mkswap` - создать swap-раздел или файл
    - `swapon` и `swapoff` - использование swap-раздела. Выполняются системой при пуске/выключении.
- `mke2fs` - создать файловую систему ext2/ext3/ext4
- `mkdosfs` - создать файловую систему DOS FAT
- `mkfs.<fsname>` - создать файловую систему
    - Примеры: `mkfs.ext4`, `mkfs.fat`, `mkfs.ntfs` -
- `wipefs` - стереть сигнатуру файловой системы с устройства
- `fsck` - проверить или починить файловую систему
    - Пример: `fsck.ext4 -fn /dev/sda1` - простая проверка
        - Показывает фрагментацию системы, помимо всего прочего
- `debugfs` - отлаживать файловую систему ext*
    - Иногда используется для восстановления удаленных файлов
- `tune2fs` - вывести/настроить список параметров в файловой системе ext* 
    - Пример: `tune2fs -l /dev/sda1` - вывести информацию о ФС, н-р когда она была создана
    - Пример: `tune2fs -L /dev/sda1 "MyLabel"` - назначить метку "MyLabel" для файловой системы

<a name="systemcmd-filesys-block"></a>
### Работа с Блочными Устройствами

- `blkid` - вывести аттрибуты блочного устройства (тип фс, мета-информация, и тд)
- `lsblk` - вывести названия и аттрибуты блочных устройств
    - Без аргумента предоставляет вывод для всех устройств
        - Можно указать конкретное, н-р `lsblk /dev/sda`
    - Пример: `lsblk -f` - имя, тип фс, метка, точка монтирования 
    - Пример: `lsblk -ao NAME,FSTYPE,FSSIZE,FSUSED,FSUSE%` 

- `hdparm` - вывести или изменить параметры диска.
- `badblocks` - проверить диск на наличие сбойных блоков
    - Пример: `badblocks -w -s /dev/sdX -o badblocks.out`
        - `-s` - показывать прогресс
        - `-w` - тестировать запись. Перезапишет имеющиеся данные!
        - Тест записи может занять много времени. Например, HDD на 1ТБ может потребовать ~70 часов на проверку.
- `smartctl` - проверить/настроить SMART диск (SSD, NVME)

- `fdisk` - создать или изменить таблицу разделов на диске
    - `fdisk -l` - вывести таблицу разделов на всех устройствах
        - `fdisk -l /dev/sdX` - вывести таблицу разделов на диске sdX
- `kpartx` - создать таблицу разделов для любого устройства
    - Пример: добавить/удалить разделы для lvm-раздела с образом виртуальной машины Windows
        - `kpartx -a /dev/mapper/WindowsVMVolume`
        - `kpartx -d /dev/mapper/WindowsVMVolume`

<a name="systemcmd-filesys-chroot"></a>
### Chroot

- `chroot` - запустить команду (в тч shell) с другой рут-директорией (тюрьмой)
    - `chroot /path/to/new/root somecommand`
    - `chroot /path/to/new/root` - запустить bash
    - Пример: Чаще всего используется для исправления "сломанной" операционной системы
        - переустановка загрузчика
        - восстановление пароля
        - обновление ядра
        - и т.п.
    - Пример: chroot иногда используют для того, чтобы запускать программы из-под другого дистрибутива
        - Н-р, можно запустить 32-х битный дистрибутив на 64-х битном (для кросс-компиляции)
    - Пример: можно использовать как песочницу, однако из chroot-тюрьмы легко выбраться
    - Чтобы внутри chroot-а можно было полноценно работать, в нем должны быть доступны файловые системы ядра
    
            for i in /dev /dev/shm /dev/pts /proc /sys /run; do
                mount --bind "$i" /path/to/chroot/"$i";
            done
            cp /etc/resolv.conf /path/to/chroot/etc/resolv.conf

<a name="systemcmd-filesys-lvm"></a>
### LVM

- `lvs` - вывести список логических томов
- Увеличить размер логического тома
    
        lvextend -L +10G lvgroup/lvvolume
        resize2fs /dev/vgdevice/lvvolume

<a name="systemcmd-network"></a>
## Сеть

По состоянию на 2020-й год пакет net-tools (програмы ifconfig, route, netstat, и т.д.) предполагается заменять более новыми утилитами, в частности пакетом iproute2 (программы ip и ss). Тем не менее, старые утилиты все еще установлены на большинстве дистрибутивов.

- Устаревшие утилиты
    - `ifconfig` - кофигурировать сетевой интерфейс
        - Пример: `ifconfig -a` - показать доступные сетевые интерфейсы
    - `iwconfig` - аналог `ifconfig` для беспроводных интерфейсов
    - `route` - показать/изменить таблицу маршрутизации
    - `netstat` - показать сетевую статистику (н-р активные соединения, таблицу маршрутизации)
    - `arp` - показать таблицы arp - связи между ip- и mac-адресами

- Утилиты на замену
    - `ip` - показать/изменить маршрутизацию, конфигурацию сетевых устройств и др.
        - Пример: `ip -c link` - показать доступные сетевые интерфейсы
            - замена `ipconfig -a`
        - Пример: `ip addr` - показать ip адреса на устройствах
        - Пример: `ip route` - показать таблицу маршрутизации
            - замена `netstat -r`
        - Пример: `ip n` - показать таблицу соседей
            - замена `arp -a`
    - `iw` - замена `iwconfig`
    - `ss` - статистика сокетов 
        - См. [Сетевая Статистика](#systemcmd-stat-net)
        - В ядре >=4.9 c помощью `ss -K` можно уничтожать сокеты:
            - Пример: `ss -K dst xxx.xxx.xxx.xxx`

- `nmcli` - интерфейс командной строки для сервиса NetworkManager
    - TODO
    - `nmcli device wifi list` - вывести достижимые точки доступа wifi
    - `nmcli device wifi connect "$SSID" password "$PASSWORD"` - подключиться в wifi
        `nmcli --ask device wifi connect "$SSID"` - скрытая печать пароля
    - Вывести информацию о wifi-интерфейсе wlan0
        `nmcli -p -f general,wifi-properties device show wlan0`
    - Network Manager установлен на большинстве дистрибутивов (2021)
    - Если нужно настроить сеть вручную, нужно предварительно остановить сервис NetworkManager

- `rfkill` - управление беспроводными устройствами - wifi-, bluetooth-модулями

<a name="systemcmd-network-iptables"></a>
### Iptables

- `iptables` - управление таблицами маршрутизации/фильтрации IP-пакетов

    - Основы iptables
        - Фильтрация пакетов запрограммирована в ядре и организована с помощью таблиц. 
        - Таблица состоит из цепей - последовательностей правил, которые выполняются по порядку.
        - Правило состоит из предиката выборки и цели - действия, которому подвергнется пакет подходящий под предикат.
        - В конце цепи находится цель policy, которая определяет конечное назначение пакета.
        - В iptables есть 5 таблиц: raw, filter, nat, mangle, security.
            - Базовая администрация вряд ли выйдет за рамки таблиц nat и fitler
                - nat - проброс портов
                - filter - таблица по умолчанию, где обычно задают фильтрацию пакетов
            - В filter по умолчанию есть 3 цепи - INPUT, OUTPUT, и FORWARD
            - Порядок обхода цепей:

                                                   XXXXXXXXXXXXXXXXXX
                                                 XXX     Network    XXX
                                                   XXXXXXXXXXXXXXXXXX
                                                           +
                                                           |
                                                           v
                     +-------------+              +------------------+
                     |table: filter| <---+        | table: nat       |
                     |chain: INPUT |     |        | chain: PREROUTING|
                     +-----+-------+     |        +--------+---------+
                           |             |                 |
                           v             |                 v
                     [local process]     |           ****************          +--------------+
                           |             +---------+ Routing decision +------> |table: filter |
                           v                         ****************          |chain: FORWARD|
                    ****************                                           +------+-------+
                    Routing decision                                                  |
                    ****************                                                  |
                           |                                                          |
                           v                        ****************                  |
                    +-------------+       +------>  Routing decision  <---------------+
                    |table: nat   |       |         ****************
                    |chain: OUTPUT|       |               +
                    +-----+-------+       |               |
                          |               |               v
                          v               |      +-------------------+
                    +--------------+      |      | table: nat        |
                    |table: filter | +----+      | chain: POSTROUTING|
                    |chain: OUTPUT |             +--------+----------+
                    +--------------+                      |
                                                          v
                                                   XXXXXXXXXXXXXXXXXX
                                                 XXX    Network     XXX
                                                   XXXXXXXXXXXXXXXXXX

        - Изначально в цепях нет правил, но есть `policy` по умолчанию - обычно `ACCEPT`.
        - Встроенные цели: `ACCEPT`, `DROP`, `QUEUE`, `RETURN`.

    - Интерфейс командной строки iptables:
        - `-t table` - определяет, в отношении какой таблицы будет выполнена команда.
            - Если не указывать, то будет выбрана таблица по умолчанию - `filter`
        - `-L [chain]` - показать правила для всех цепей в таблице или для указанной.
        - `-P chain target` - изменить policy цепи
        - Управление правилами:
            - `-A chain rule` - добавить правило в конец цепи
            - `-I chain [rulenum] rule` - вставить правило в указанном месте
            - `-R chain rulenum rule` - заменить правило 
            - `-D chain rulenum` - удалить правило
        - Простые параметры правил:
            - `-p protocol` - протокол пакета или правила
            - `-s address[/mask]` - адрес источника пакета
            - `-d address[/mask]` - адрес назначения пакета
            - `-j target` - цель пакета
        - Примеры
            - `iptables -t nat -L` - показать правила всех цепей в таблице `nat`
            - `iptables -P FORWARD DROP` - заблокировать маршрутизацию.
            - `iptables -I INPUT -s xxx.xxx.xxx.xxx -j DROP` - сбрасывать все пакеты от указанного IP
            - https://wiki.archlinux.org/title/Simple_stateful_firewall
            - https://wiki.archlinux.org/title/Router
        - Конфигурация сервиса iptables
            - `iptables` установлен на большинстве дистрибутивов и работает как сервис.
            - Сохранять правила для последующих загрузок нужно вручную
                - `iptables-save -f /etc/iptables.rules` - Arch Linux
                - `iptables-save > /etc/iptables/rules.v4` - Debian.
                    - В Debian также нужно установить пакет iptables-persistent

    - См. также: https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html
    - `nftables` - предполагаемая замена `iptables`. Однако, `iptables` пока (2021) не теряет в популярности.

<a name="systemcmd-etc"></a>
## Разное

- `xrandr` - команда для манипуляций с корневым окном в X Window System
    - Пример: `xrandr` - список устройств вывода и доступных для них режимов изображения
    - Пример: `xrandr --output DVI-D-0 --mode "1920x1080" - задать режим для устройства
- `xgamma` - команда для настройки гаммы монитора
    - Пример: `xgamma -gamma 1.5` - может помочь в некоторых старых играх

<a name="recipes"></a>
# Рецепты

<a name="recipes-admin"></a>
## Администрирование Linux

<a name="recipes-admin-netconfig"></a>
### Проверка и Настройка Сети

Примерный порядок действий при ручной настройке/диагностике сети. Если дистрибутив использует NetworkManager, его нужно предварительно отключить.

1. Для беспроводных устройств, проверяем загружен ли драйвер.
    - `lspci -k` - для pci(e) устройств
    - `lsusb -k` - для usb устройств
    - `dmesg | grep firmware` - проверяем сообщения ядра - была ли загружена прошивка
        - `dmesg | grep iwlwifi` - можно проверить по имени модуля ядра, который был указан `lspci`/`lsusb`

1. Сетевой интерфейс определяется и включен
    - `ip link` 
    - Ручное включение:
        
            ip link show dev enp2s0 # статус должен быть DOWN
            ip link set $interface_name up|down # включить/выключить интерфейс

1. Интерфейс подключен: кабель в гнезде / устройство подключено к WLAN
    - Подключение к WiFi, схема безопасности WLAN WEP
            

            iw dev $interface_name scan # list available wlans
            iw dev $interface_name connect $your_essid key 0:$your_key 

    - Подключение к WiFi, схема безопасности WLAN WPA2

            # Создаем базовый файл конфигурации wpa_supplicant
                /etc/wpa_supplicant/wpa_supplicant.conf
                ctrl_interface=/run/wpa_supplicant
                update_config=1

            wpa_supplicant -B -i $interface_name -c /etc/wpa_supplicant/wpa_supplicant.conf
            wpa_cli
                scan
                add_network
                set_network 0 ssid "MYSSID"
                set_network 0 psk "passphrase"
                enable_network 0
                save_config
                quit

1. IP-адрес и шлюз настроены.
    - Без DHCP
        1. Сетевому интерфейсу присвоен IP-адрес
            - `ip address show`
            - Ручная настройка:
        
                    # Присвоить интерфейсу адрес:
                    ip address add ${address}/${prefix_len} broadcast + dev ${interface}
                    # Удалить
                    ip address del ${address}/${prefix_len} dev ${interface}
        
        1. Настроен шлюз
            - `ip route show`, `ip -6 route show` - для ipv6
            - Ручная настройка
        
                    ip route add ${PREFIX} via ${address} dev ${interface}
                    ip route del ${PREFIX} via ${address} dev ${interface}
    - C DHCP
        - DHCP-сервер предоставляет динамический IP, маску подсети, шлюз по умолчанию и опционально DNS-сервера.
        - `dhclient ${interface}` - принять динамическую конфигурацию

1. Шлюз по умолчанию пингуется
    - `ping 192.168.1.1`

1. Публичные IP-адреса пингуются
    - `ping 8.8.8.8` - популярный адрес Гугла

1. DNS-имена раскрываются
    - `host google.com`
    - Если нет, проверяем, присвоен ли dns и доступен ли он

            cat /etc/resolv.conf 
            ping $your_supposed_dns 

<a name="recipes-admin-automount"></a>
### Настройка Автоматического Монтирования

        # Узнаем имя диска
        sudo fdisk -l | grep sd
        # Узнаем UUID этого диска, пусть оно будет 2d838da3-f4c3-4113-8126-92293da47fd6
        ls -l /dev/disk/by-uuid/
        # Добавляем запись в /etc/fstab
        echo "#This is my drive" >> /etc/fstab
        echo "UUID=2d838da3-f4c3-4113-8126-92293da47fd6             /DATA                 ext4 defaults 0 1" >> /etc/fstab
        # Эта команда перечитает /etc/fstab и смонтирует недостающие точки
        sudo mount -a

<a name="recipes-admin-lvm"></a>
### Бэкап с Помощью LVM

        # создаем снэпшот
        lvcreate -s -n snapshot_name -L 1G lvgroup/lvolume
        # монтируем его
        mount /dev/lvgroup/snapshot_name /mnt/snapshot_name
        # делаем бэкап тем или иным способом
        tar -cf /path/to/backup /mnt/snapshot_name"
        # удаляем снэпшот, чтобы не пострадала производительность,
        # т.к. всё, что пишется в оригинал, копируется в снэпшот
        umout /mnt/snapshot_name 
        lvremove lvgroup/snapshot_name

<a name="recipes-admin-samba"></a>
### Samba

- `net` - администрация Samba и CIFS
    - `net rpc users` - перечислить пользователей
    - `net rpc share list -U $USERNAME` - перечислить ресурсы пользователя
    - См. `man 8 net`

- `smbclient` - клиент для доступа к samba/cifs
    - `smbclient -L $host -U $your_username` - перечислить доступные сервисы

- `smbstatus` - информация о текущих соединения samba

- Монтировать файловую систему Samba под названием "shares", расположенную на 192.168.1.88:

        mount -t cifs -o username=$USERNAME,password=$PASSWORD //192.168.1.88/shares /mnt/share

- См. https://tldp.org/HOWTO/SMB-HOWTO.html#toc8

<a name="recipes-admin-lamp"></a>
### LAMP

- Установка на APT:

        apt install apache2 
        apt install php-common libapache2-mod-php php-cli php-mysql
        # Конфиги: /etc/apache2/mods-enabled/php-${version}.{conf,load}
        apt install mariadb-server # ?
        service apache2 start

    - PHP-FPM вместо mod-php:
        - TODO

- Базовые команды Apache:
    - `a2enmod`, `a2dismod` - включить/выключить модуль Apache
        - Конфиги модулей: `/etc/apache2/mods-{available,enabled}`
    - `a2ensite`, a2dissite - включить/выключить сайт
        - Конфиги сайтов: `/etc/apache2/sites-{available,enabled}`
    - `apachectl configtest` # проверить конфигурацию
    - `systemctl reload apache2` - перечитать конфиг без полной перезагрузки
    - `systemctl restart apache2` - при включении новых модулей нужна полная перезагрузка

- Типичные директории размещения сайтов
    - `/var/www`
    - `/var/www/sites/$vhost_name`

- Права доступа к файлам
    - Разработчик сайта (а лучше какая-то система релизов) должна иметь эти разрешения:

            read/write на файлы
            read/write/execute на директории

    - Анонимные пользователи (посетители вебсайта) имеют доступ к системе через пользователя Apache. У него должны быть минимальные права.
        - `ps aux | grep (httpd|apache)` - под каким пользователем работает Apache (обычно www-data)
        - Какие должны быть разрешения у этого пользователя:

                read на файлы и интерпретируемые скрипты
                read/execute на отдаваемые директории
                read/write/execute на директории с загружаемым контентом

        - Загрузки, которые не должны отдаваться, нужно хранить за пределами webroot-а

- Включение TLS
    - Подготавливаем файл с сертификатом. За неимением покупного, можно воспользоваться самописным:

            openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/apache-selfsigned.key -out /etc/ssl/certs/apache-selfsigned.crt

    - `a2enmod ssl` - должен быть активен mod_ssl

    - Конфигурируем vhost:
    
            <VirtualHost *:443>
               ServerName your_domain_or_ip
               DocumentRoot /var/www/your_domain_or_ip
            
               SSLEngine on
               SSLCertificateFile /etc/ssl/certs/apache-selfsigned.crt
               SSLCertificateKeyFile /etc/ssl/private/apache-selfsigned.key
            </VirtualHost>

            # Можно перенаправлять http на https
            <VirtualHost *:80>
            	ServerName your_domain_or_ip
            	Redirect / https://your_domain_or_ip/
            </VirtualHost>

- Настройка Wordpress
    - Создаем базу данных
        - Хостер может предоставлять инструменты Plesk, cPanel, phpMyAdmin
        - MySQL:

                CREATE DATABASE wpdbname;
                CREATE USER 'wpusername'@'localhost' IDENTIFIED BY 'password';
                    # localhost if db on same machine
                    # best password: upper-, lower-case letters, numbers, and symbols
                GRANT ALL PRIVILEGES ON wpdbname.* TO 'wpusername'@'localhost'

    - Загружаем, распаковываем архив с Wordpress
        - Помещаем папку Wordpress в подходящее место (обычно webroot или webroot/blog)
    - Создаем `wp-config.php`
        - В архиве должен быть `wp-config-sample.php`
    - Запускаем скрипт установки через браузер: website-url/wp-admin/install.php

    - Права
        - Во время установки, может понадобиться право write на все файлы wp 

                chown www-data:www-data -R $wp-root/*
                find $wp-root/* -type d -exec chmod 755 {} \; # dirs: rwxr-xr-x
                find $wp-root/* -type f -exec chmod 644 {} \; # files: rw-r-r--

        - После установки, желательно уменьшить права

                chown <your_user>:<your_user> -R $wp-root/*
                chown www-data:www-data wp-content
        - См. также: https://wordpress.org/support/article/hardening-wordpress/

<a name="recipes-virt"></a>
## Виртуализация

<a name="recipes-virt-lxc"></a>
### Контейнеры LXC

- LXC - система виртуализации основанная на cgroups и namespaces
    - Изолирует ОС Linux в контейнере, который работает на ядре хоста

- Установка
    - `sudo apt install lxc` - Debian-based
    - `lxc-checkconfig` - проверить подходит ли ядро

- Непривилегированные контейнеры
    - Такие контейнеры отображают uid и gid так, что рут контейнера будет иметь н-р uid 100000 за пределами контейнера
        - Если пользователь и выйдет из контейнера, прав у него будет не больше, чем у nobody
        - Минус: нельзя монтировать, создавать устройства, делать что-либо с другими uid/gid
        - Поэтому для lxc делают готовые образы дистрибутивов
    - Для использования нужны subuid и guid
        - Проверить: `cat /etc/subuid; cat /etc/subgid`
        - В Debian-ах по умолчанию должно быть 65536, начиная с 100000
        - Если нет, то нужно добавить с помощью `usermod`
    - Сеть: разрешить пользователю создавать до 10 veth устройств, подключаемых к мосту lxcbr0
        - `echo "$(id -un) veth lxcbr0 10" | sudo tee -a /etc/lxc/lxc-usernet`
    - Создаем базовый конфиг:

            cp /etc/lxc/default.conf ~/.config/lxc/default.conf

            # Значения должны соответствовать /etc/subuid и /etc/subgid
            echo "lxc.idmap = u 0 100000 65536" >> ~/.config/lxc/default.conf
            echo "lxc.idmap = g 0 100000 65536" >> ~/.config/lxc/default.conf

            # Debian wiki так же рекомендует:
            echo "lxc.apparmor.profile = unconfined" >> ~/.config/lxc/default.conf
            echo "lxc.apparmor.profile = lxc-container-default-cgns" >> ~/.config/lxc/default.conf

    - Так же может быть нужно добавить права на директорию:

            setfacl -m u:100000:x ~
            setfacl -m u:100000:x ~/.local
            setfacl -m u:100000:x ~/.local/share

    - При создании/старте непривилегированного контейнера, нужно делегировать пользователю cgroup
        - В systemd, можно запускать соответствующие команды как

                systemd-run --unit=my-unit --user --scope -p "Delegate=yes" -- *cmd*

        - В openrc: https://wiki.gentoo.org/wiki/LXC#Create_user_namespace_manually_.28no_systemd.29

- Базовое управление контейнерами:
    - `lxc-create -t download -n my-container` - создать контейнер, выбрав из готовых образов Linux
        - `~/.local/share/lxc/my-container/` - директория неприв. контейнера по умолчанию
    - `lxc-ls` - список контейнеров
    - `lxc-info -n my-container` - получить информацию о состоянии контейнера
    - `lxc-start my-container` - запустить 
    - `lxc-attach -n my-container` - получить доступ к оболочке контейнера
    - `lxc-stop -n my-container` - остановить
    - `lxc-remove -n my-container` - удалить

- Монтирование внешних файловых систем
    - Добавить в конфиг `~/.local/share/lxc/my-container/config`

            lxc.mount.entry = /path/in/host path/in/guest none bind 0 0

    - Гостевой путь должен быть относительным.
    - В непривилегированных контейнерах нужно принимать во внимание отображение UID и GID
        - Чтобы устройства принадлежали руту в контейнере, можно на хосте делать н-р

                chgrp 100000 /dev/nvidiactl

        - Для /home можно отобразить UID 1000 в контейнере на UID 1000 на хосте:
                
                lxc.mount.entry = /home home none bind,rw 0 0

                lxc.idmap = u 0 100000 1000
                lxc.idmap = g 0 100000 1000
                lxc.idmap = u 1000 1000 1
                lxc.idmap = g 1000 1000 1
                lxc.idmap = u 1001 101001 64535
                lxc.idmap = g 1001 101001 64535

- Сеть
    - TODO: https://linuxcontainers.org/lxd/docs/master/howto/network_forwards/

<a name="recipes-virt-qemu"></a>
### Qemu и KVM

- Что такое `qemu` и `kvm`
    - `qemu` - эмулятор аппаратного обеспечения
    - `kvm` - гипервизор, встроенный в ядро Linux
    - При совместной работе KVM управляет доступом к ЦПУ и памяти, а QEMU эмулирует периферию (жесткий диск, видеокарту, usb, и т.д.)
    - При работе в соло, QEMU эмулирует все железо, в тч ЦПУ

- Установка на APT: `apt install qemu qemu-utils qemu-system-x86 qemu-system-gui`
    - Есть и другие эмуляторы: `qemu-system-arm`, `qemu-system-mips`, и т.д.

- Для KVM процессор должен поддерживать виртуализацию (VT-x для Intel, AMD-V для AMD)
    - `LC_ALL=C lscpu | grep Virtualization` - проверка
        - Если не включено, нужно это сделать в Биосе
    - `lsmod | grep kvm` - проверка, загружены ли модули для KVM
        - должны быть загружены модули kvm и kvm_intel / kvm_amd

- Создать образ жесткого диска:
    - `qemu-img create debian.img 2G`
    - `qemu-img create -f qcow2 debian.qcow 2g` - специальный формат QEMU

- Загрузить систему:
    - `qemu-system-x86_64 -m 2048 -drive file=debian.img,format=raw`
    - `-enable-kvm` - с этим флагом QEMU будет использовать KVM
    - `-cdrom debian-testing-amd64-netinst.iso -boot d` - для первой загрузки

- Общий доступ к файлам
    - Пользовательская сеть по умолчанию дает доступ к хосту на 10.0.2.2
    - Qemu также может запустить Самбу на хосте
        - `-nic user,id=nic0,smb=shared_dir_path`
        - Доступ к ней будет через //10.0.2.4/qemu
        - В Windows туда можно попасть через File Explorer -> \\10.0.2.4\qemu в адресной панели

- Проброс USB
    1. Определяем устройство

            lsusb
                ...
                Bus 003 Device 007: ID 0781:5406 SanDisk Corp. Cruzer Micro U3

    1. Эмулируем контроллер USB EHCI (USB 2) или XHCI (USB 1.1, 2, 3)

            -device usb-ehci,id=ehci # or
            -device usb-xhci,id=xhci # id value will be used later in bus

    1. Добавляем к контроллеру устройство
        - `-device usb-host,bus=ehci.0,vendorid=0x0781,productid=0x5406` - по ID
        - `-device usb-host,bus=ehci.0,hostbus=3,hostaddr=7` - по шине и адресу
        - `-device usb-host,hostdevice=/dev/bus/usb/003/007` # по шине и адресу (QEMU 5.1.0+)

- Проброс портов:

        # Связываем хост-порт 60022 с гостевым портом 22 (SSH), 5900 с 5900.
        -nic user,hostfwd=tcp::60022-:22,hostfwd=tcp::5900-:5900

- Импорт виртуальной машины из ova файла

        tar xvf <ova-file-name> # на выходе будет .vmdk образ
        qemu-img convert -O qcow2 <source-disk.vmdk> <dest-disk.qcow2>

        # Нужно запомнить значения этих параметров из файла OVF:
        Disk ovf:capacity
        Number of Virtual CPUs (ResourceType 3)
        Memory Size (ResourceType 4)
        PCNet32 ethernet adapter (ResourceType PCNet32)

- См. также
    - https://www.qemu.org/docs/master/index.html
    - https://wiki.debian.org/QEMU
    - https://wiki.debian.org/KVM
    - https://wiki.archlinux.org/title/QEMU
    - https://wiki.archlinux.org/title/KVM
    - https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF

<a name="recipes-debian"></a>
## Debian

<a name="recipes-debian-install"></a>
### Установка Debian 11

1. Подготовка загрузочной флешки
    - Скачиваем минимальный (netinst) образ
    - `cp debian.iso /dev/sdX`

1. Разметка дисков и установка
    - Разметка
            
    	    # On a BIOS computer firmware:
            1 GB: Primary, Beginning, Use as: ext4, Mount point: /boot, Bootable: on
    	    # On a UEFI computer firmware:
    	    550 MB: Beginning, Use as: EFI, Bootable: on
            # Оставшееся место
            primary, Use as: logical volume for LVM

    - Создание LVM разделов

            LVM: A GB root, B GB swap, C GB tmp, D GB var, F GB home
            A = минимум 8, лучше 15+
            B = если RAM <= 2GB то 2xRAM (3x для гибернации)
                    2GB-8GB 1xRAM (2x для гибернации)
                    8GB-64GB >=4 (1.5x для гибернации)
                    64GB >= 4 (гибернация не рекомендована)
            C = 1
            D = 5 достаточно; можно довести ~20 для н-р хостинга
            F = сколько нужно

    - Разделы: Ext4 для root,tmp,var, и home; swap для swap
    - Далее последует установка. Галочку с Desktop Environment лучше убрать, чтобы не устанавливать ненужное

1. После установки, правим sources list:

        # Для Stable дистрибутива:
        deb http://deb.debian.org/debian bullseye main contrib non-free
        deb-src http://deb.debian.org/debian bullseye main contrib non-free
        
        deb http://deb.debian.org/debian-security/ bullseye-security main contrib non-free
        deb-src http://deb.debian.org/debian-security/ bullseye-security main contrib non-free
        
        deb http://deb.debian.org/debian bullseye-updates main contrib non-free
        deb-src http://deb.debian.org/debian bullseye-updates main contrib non-free

        # К Stable можно добавить backports
        deb http://deb.debian.org/debian bullseye-backports main contrib non-free
    
        # Для  Unstable:
        deb http://deb.debian.org/debian/ unstable main contrib non-free
        deb-src http://deb.debian.org/debian/ unstable main contrib non-free
    
        # К Unstable можно добавить Experimental, н-р для nvidia-driver
        deb http://deb.debian.org/debian experimental main contrib non-free

1. При выборе unstable нужно обновиться

        apt update
        apt full-upgrade

1. Если доступ к интернету только по WiFi, могут быть проблемы
    - Загружаемся с Live-дистрибутива на котором работает интернет, например SystemRescue
    - Делаем Chroot в установленный Debian
    - Устанавливаем драйвера для устройства

            # Мой компьютер с адаптером tp-link RTL8188EE
            apt install firmware-realtek # нужен non-free репозиторий
            # Мой макбук с адаптером Broadcom BCM4331 rev 02
            apt install firmware-b43-installer

    - `apt install rfkill network-manager`

1. Добавляем основного пользователя в sudoers

        su -
        apt-get update
        apt-get install sudo
        usermod -G sudo -a daniil
        # Или
        adduser daniil sudo
        # Чтобы изменения отразились, нужно перелогинить пользователя

1. Для 32-битных приложений, в частности для полноценной работы Wine, нужно добавить поддержку 32-битных програм

        dpkg --add-architecture i386
        apt install libc6-i386

1. Устанавливаем драйвер видеокарты
    - Nvidia

            # Чтобы собрать драйвер, нужны заголовки ядра
            apt install linux-headers-amd64 
            # Устанавливаем драйвер. Перед этим нужно убедиться что contrib и non-free sources активированы
            apt update
            apt -t experimental install nvidia-driver # -t experimental if you have experimental branch enabled
            apt install firmware-misc-nonfree
            # 32-bit Wine support
            # Поддержка 32-х битных приложений
            apt install nvidia-driver-libs:i386
            # Check if the drivers are working:
            # Проверяем работу
            lspci -k # "kernel driver in use" видеокарты должен быть nvidia
            nvidia-smi # должен написать версию используемого драйвера

1. Устанавливаем Flatpak
    - Некоторые приложения, н-р Gimp с плагинами, лучше устанавливать из Flatpak
    - Установка

            apt install flatpak 
            flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
            # Flatpak plugin for DE's Software Center:
            apt install plasma-discover-backend-flatpak # kde discover
            apt install gnome-software-plugin-flatpak # gnome software

<a name="recipes-debian-apt"></a>
### Менеджмент Пакетов c APT

- См: https://www.debian.org/doc/manuals/debian-faq/
- Формат нумерации версий: `man deb-version`

- `dpkg` - менеджер пакетов Debian
    - `dpkg -l` - вывести пакеты в базе dpkg
        - В первой колонке указаны желательное действие и текущий статус
            - Пример: `ii` означает что пакет нужно установить и он установлен
    - `dpkg -L package` - вывести файлы установленные из пакета
    - `dpkg -S /path/to/file` - из какого пакета установлен конкретный файл
    - `/var/log/dpkg.log*` - история менеджера пакетов

- `apt` - продвинутый менеджер пакетов
    - `apt search pattern` - искать пакет в описании которого встречается паттерн
        - `--names-only` - паттерн встречается только в имени
    - `apt -s command` - симуляция: напечать, что будет выполнено при команде `apt command`
    - `apt build-dep packagename` - установить зависимости необходимые для сборки пакета

- `apt-file` - искать файлы в APT-пакетах
    - `apt-file` проверяет пакеты в репозиториях
    - `apt-file search pattern` - в каких пакетах есть файл с именем попадающим в pattern
        - Пример: `apt-file search /etc/magic`
    - `apt-file list package` - показать файлы которые установит пакет

- Использование Debian Unstable
    - Желательно установить пакеты `apt-listbugs` и `apt-listchanges`. Они работают автоматически.
    - Установку пакетов можно отложить с помощью `apt-mark`

            apt-mark hold emacs
            apt-mark showhold
            apt-mark unhold emacs

    - Статус багов можно смотреть на https://www.debian.org/Bugs
        - См. https://wiki.debian.org/HowtoUseBTS
    - Желательно делать бэкапы (н-р с помощью LVM-снэпшотов) перед установкой обновлений

- Установка пакетов из других веток
    - Не стоит устанавливать пакеты из unstable/testing в stable
    - Однако, можно устанавливать из backports в stable и из experimental в unstable
    - Сперва необходимо добавить соответствующий репозиторий

            # Backports для Bullseye
            deb http://deb.debian.org/debian bullseye-backports main contrib non-free

            # Experimental
            deb https://deb.debian.org/debian experimental main contrib non-free

    - Установка

            # Посмотреть все варианты пакета:
            apt show packagename -a

            # Backports для Bullseye
            apt -t bullseye-backports install packagename

            # Experimental
            apt -t experimental install packagename

    - Можно закрепить пакет так, что `apt` будет следить за ним в определенной ветке

            # Создаем файл-preference. Для примера возьмем nvidia-driver
            # /etc/apt/preferences.d/nvidia-experimental
            Package: nvidia-driver
            Pin: release a=experimental
            Pin-Priority: 800

            # Проверяем приоритет источника в пакете:
            apt-cache policy nvidia-driver

<a name="recipes-desktop"></a>
## Графическое Окружение

<a name="recipes-desktop-wayland"></a>
### Wayland

- Проверка, используется ли Wayland: `echo $XDG_SESSION_TYPE`
- Для запуска x11 приложений нужен xwayland (должен быть установлен автоматически)
    - Проверить, использует ли приложение xwayland:
        - запустить `xwininfo`
        - курсор превратится в крестик под x11 приложением
        - если нажать на экран с x11 приложением, программа завершится с печатью свойств окна

<a name="recipes-desktop-kde"></a>
### KDE

- Установка
    - APT: `apt install kde-plasma-desktop plasma-nm kde-config-sddm`

- Настройка экрана логина:
    - System Settings -> Login Screen

- Wayland
    - `apt install plasma-workspace-wayland` 
    - В конце 2021 с Nvidia едва ли работает

- Базовые приложения:
    - Архиватор: Ark
    - Просмотр Документов: Okular
    - Просмотр Изображений: Gwenview
    - Видео-Плеер: VLC
    - Создание превьюшек видео: Dolphin FFmpeg Thumbnailer
    - Торрент-Клиент: qBittorrent

- Проблема с `lm_sensors`: `KDE Plasma Thermal Monitor` не работает при включении.

        # $HOME/.local/share/plasma/plasmoids/org.kde.thermalMonitor/contents/ui/main.qml
        # заменить "property var systemmonitorAvailableSources"
        # на "property var systemmonitorAvailableSources: []"

<a name="recipes-desktop-gnome"></a>
### Gnome

- Установка
    - `apt install gnome-core`

- Wayland

        # /usr/lib/udev/rules.d/61-gdm.rules
        # There are two lines that start with
        LABEL="gdm_prefer_xorg"
        LABEL="gdm_disable_wayland"
        # Comment (with #) the line that starts with RUN after each of these two

        # /etc/gdm3/daemon.conf
        WaylandEnable=true

- Расширения
    - Установка с APT
        - `apt install gnome-extensions`
        - `apt search --names-only gnome-shell-extension`
    - Использование: `gnome-extensions list | show | enable | disable [extname]`
    - Полезные:
        - Dash to Panel - заменяет top-bar dock-панелью в стиле OS X
        - Dash to Dock - добавляет dock-панель в стиле OS X
            - Hide Top Bar - убирает top-bar
        - Ubuntu AppIndicators - добавляет поддержку трей-иконок в top-bar
        - System Monitor
        - Freon

<a name="recipes-devices"></a>
## Linux на Специфичном Оборудовании

<a name="recipes-devices-mac"></a>
### Mac

- Нужно установить `lm-sensors` и `macfanctld` для правильной работы вентиляторов
- Проблема с `lm_sensors`: модуль it87 не загружается:
    - Добавить параметр ядра `acpi_enforce_resources=lax` в `/etc/default/grub`
- Поддержка трэкпада
    - `mtrack` работает лучше, чем `libinput` (2022)
    - Конфигурация `mtrack`:

            # /etc/X11/xorg.conf.d/mtrack.conf
            # См. /usr/share/doc/xserver-xorg-input-mtrack/README.md.gz
            Section "InputClass"
                    MatchIsTouchpad "on"
                    Identifier      "Touchpads"
                    MatchDevicePath "/dev/input/event*"
                    Driver          "mtrack"
                    # Скорость движения курсора
                    Option          "Sensitivity" "0.33"
                    # Скорость прокрутки 
                    Option          "ScrollDistance" "250"
                    # Кнопки интегрированы в трэкпад
                    Option          "ButtonIntegrated" "true"
            	    # Disable rotation to enhance pinch
                    # Убрать поворот, чтобы улучшить "щипок"
            	    Option "RotateLeftButton" "0"
            	    Option "RotateRightButton" "0"
            	    # Tapping. Setting TapButton-s to 0 disables tapping.
                    # Тапы. Установка TapButton в 0 отключает тап.
            	    Option "TapButton1" "0" # 1 для эмуляции ЛКМ при тапе одним пальцем
            	    Option "TapButton2" "0" # 3 для эмуляции ПКМ при тапе двумя пальцами
            	    Option "TapButton3" "0" # 2 для эмуляции СКМ при тапе тремя пальцами
            	    Option "TapButton4" "0"
                    Option "MaxTapTime" "120" # сколько мс ждать завершения тапа, прежде чем счесть его движением курсора
                    Option "MaxTapMove" "400" # как далеко(?) может сдвинуться тап, прежде чем счесть его движением
                    # Tap-to-drag (активируется двойным тапом) включен по умолчанию. 
                    # В некоторых приложениях, где есть и drag и двойной щелчок, можно добиться tap-to-drag с помощью трех тапов
            EndSection

<a name="recipes-devices-etc"></a>
### Разные Устройства

- Управление PWM-вентиляторами
    
        sensors-detect
        pwmconfig

<a name="recipes-userapp"></a>
## Пользовательские Приложения

<a name="recipes-userapp-websurf"></a>
### Web-Сёрфинг

- qutebrowser - минималистичный браузер на qt с vim-like управлением
- firefox
    - "Дезондирование": https://wiki.archlinux.org/title/Firefox/Privacy
        - Также можно установить librewolf
    - Активация Wayland в Firefox из Flatpak-а:

            # Одноразовый запуск
            flatpak run --socket=wayland --env=MOZ_ENABLE_WAYLAND=1 org.mozilla.firefox

            # Сделать опцию постоянной. Можно для одного пользователя с опцией --user
            flatpak override --socket=wayland --env=MOZ_ENABLE_WAYLAND=1 org.mozilla.firefox

            # Проверить в браузере: about:support -> "Window Protocol"

    - Кастомный поиск
        1. Делаем закладку поисковой страницы, н-р ищем в гугле `hello site:stackoverflow.com | site:stackexchange.com`
            - Получится закладка вида `https://www.google.com/?q=hello%20site%3Astackoverflow.com+%7C+site%3Astackexchange.com`
        1. Редактируем закладку
            - `hello` заменяем на `%s`
            - задаем Keyword, например `gts` (google tech search)
        1. Теперь при вводе в адресную строку `gts my text` в закладе будет поставляться `my text` вместо `%s`

- torbrowser
    - Не работает с apparmor (2021)

            aa-disable /etc/apparmor.d/torbrowser.Browser.firefox

    - Не может верифицировать pgp сигнатуру (2022)

            # сперва нужно запустить dirmngr без (нерабочего) tor-соединения
            pkill dirmngr
            dirmngr --debug-all --no-use-tor --daemon --homedir $HOME/.local/share/torbrowser/gnupg_homedir
            # затем можно обновить ключи
            gpg --homedir "$HOME/.local/share/torbrowser/gnupg_homedir" --refresh-keys --keyserver hkp://keyserver.ubuntu.com:80

<a name="recipes-userapp-wine"></a>
### Запуск Программ для Windows с Помощью Wine

- См.
    - https://wiki.winehq.org/Debugging_Hints
    - https://wiki.winehq.org/Debug_Channels
    - https://wiki.winehq.org/Useful_Registry_Keys

- Редактирование регистра
    - `wine regedit` - запустить редактор регистра для текущего префикса
    - Полезные ключи для починки яркости в некоторых играх:

            [HKEY_CURRENT_USER\Software\Wine\X11 Driver]
            "UseXRandR"="Y"
            "UseXVidMode"="Y"

- Steam Proton
    - Параметры запуска игры можно устанавливать в Game-Properties-Launch Options
    - Логи: `PROTON_LOG=1 %command%`
    - Использовать стандартный d3dx-opengl транслятор вместо dxvk: `PROTON_USE_WINED3D=1 %command%`
        - Последняя весрия Proton которая это поддерживает - 4.11

<a name="recipes-userapp-doc"></a>
### Работа с Документами

- `pandoc` - конвертация разных форматов разметки
    - `pandoc -f markdown -t html doc.md > doc.html` - Markdown в HTML
        - `--number-section` - этот аргумент пронумерует заголовки

- Убрать все аннотации из PDF: `rewritepdf -C in.pdf out.pdf # rewritepdf is in deb: libcam-pdf-perl`

<a name="recipes-userapp-video"></a>
### Обработка Видео

- `ffmpeg` - видео-конвертер
- `ffmpeg -i INPUT` - покажет информацию о входной файле
    - `ffprobe INPUT` - то же самое

- Копирование и кодировка потоков
    - Отображение потоков

            -map X:Y:Z # выбирает поток Y:Z из входного файла X
            -map 0 # все потоки из входного файла 0
            -map 0:v -map 0:a -map 0:s - все видео, все аудио, все субтитры соотв.
            -map 1:s:2 # поток субтитров 2 из входного файла 1

        - Если опция `-map` не указана, по умолчанию будет выбран ОДИН ПОТОК из каждого канала
        - Порядок опций `-map` определяет порядок потоков в выходном файле

    - Кодирование

            -c[:stream_specifier] codec (input/output) # выбрать кодировщик (декодировщик, если указать перед входным файлом)
            copy # использовать ту же самую кодировку
            -codecs # показать доступные (де-)кодировщики
            -encoders # кодировщики
            -decoders # декодировщики

    - См OPTIONS, Main Options в `man ffmpeg`


- Формат контейнера
    - Обычно формат автоопределяется для входного файла, угадывается по расширению выходного файла.
    - `-f fmt input | output` - форсировать использование формата
    - `-formats` - вывести доступные форматы

- Фильтры
    - Фильтры указывают перед output в виде `-filter:[stream_specifier] filtergraph`
    - `-filters` - показать все доступные фильтры
    - `man ffmpeg-filter` - подробная документация фильтров. 
        - Так же доступна по https://ffmpeg.org/ffmpeg-filters.html

- Примеры: базовые операции с потоками

        # наложить звук на видео
        ffmpeg -i vid.mp4 -i aud.m4a -c copy out.mp4
        
        # добавить субтитры к видео (mp4 поддерживает только mov_text, mkv - srt(subrip) и другие)
        ffmpeg -i video.mp4 -i subs.srt -c copy -c:s mov_text out.mp4
        
        # скопировать все потоки, перекодировать видео 1 аудио 137
        ffmpeg -i INPUT -map 0 -c:copy -c:v:1 libx264 -c:a:137 libvorbis OUTPUT
        
        # перекодировать все видео дорожки, скопировать все аудио
        ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT

- Пример: Конкатенация двух потоков

        # concat.txt:
        file 'audio1.m4a'
        file 'audio2.m4a'

        ffmpeg -f concat -safe 0 -i concat.txt -c copy audio.m4a

- Пример: извлечение кадров
        
        # `%05d` - пронумеровать файлы по конвенции 5-цифр с нулями впереди
        # Для сохранения качества можно использовать формат bmp (?)
        # См. ограничение времени обработки с помощью `-ss` и `-t`
        ffmpeg -i input filename%05d.png

- Примеры: работа со времемнем

        # добавление 2-х секундной задержки перед входным файлов
        ffmpeg -itsoffset 2 -i sub.srt -c copy delayed.srt

        # начать обработку с позиции 50сек, читать не больше минуты данных:
        # перед output `-t P` означало бы "прекратить запись если длительность output превысит P"
        # вместо `-t` можно использовать `-to P`: прекратить чтение(запись перед output) на заданной позиции
        ffmpeg -ss 00:00:50.0 -t 00:01:00.0 -i input.mp4 -c copy -t 00:01:00.0 output.mp4

- Примеры: особенности кодирования в определенные форматы

        # MP3
        # `-q:a N` - переменный битрейт; меньше N - лучше качество. При N=4 не должно быть заметных искажений
        # поддержка mp3 оффициально прекращена в 2017. Лучше использовать кодек `aac`
        ffmpeg -i input.m4a -c:v copy -c:a libmp3lame -q:a 4 output.mp3

        # WEBM
        # `-crf N` влияет на качество видео. Меньше N - тяжелее и качественнее видео.
        fmpeg -i input.mp4 -c:v libvpx-vp9 -crf 30 -b:v 0 -b:a 128k -c:a libopus output.webm

- Примеры: изменение частоты кадров

        # Замедление времени
        # извлекаем сырой bitstream
        ffmpeg -y -i input.mp4 -c copy -f h264 input.h264
        # Делаем remux с новой частотой:
        ffmpeg -y -r 24 -i input.h264 -c copy output.mp4

        # Отфильтровка лишних кадров с сохранением текущей скорости
        ffmpeg -i <input> -filter:v fps=fps=24 <output>

- Пример: исправление ошибки "Height/width not divisible by 2"

        # с помощью видеофильтра доводим размер каждой стороны до ceil(сторона/2)*2
        # и заполняем пустое пространство черными пикселями
        -vf "pad=ceil(iw/2)*2:ceil(ih/2)*2:

- Примеры: поворот видео

        # Изменяем метаданные (некоторые плееры игнорируют это).
        ffmpeg -i input.m4v -map_metadata 0 -metadata:s:v rotate="90" -codec copy output.m4v

        # Поворачиваем кадры с помощью фильтра transpose
        # transpose=1 -> поворот на 90 по часовой стрелке
        ffmpeg -i in.mov -vf "transpose=1" out.mov

- Примеры: стабилизация видео

        # Параметры взяты из ответа на stackoverflow - возможно, они лучше дефолтных
        # Генерируем данные для стабилизатора
        ffmpeg -i clip.mkv -vf vidstabdetect=stepsize=6:shakiness=8:accuracy=9:result=transform_vectors.trf -f null -
        # Применяем фильтр
        ffmpeg -i clip.mkv -vf vidstabtransform=input=transform_vectors.trf:zoom=1:smoothing=30,unsharp=5:5:0.8:3:3:0.4 \
            -vcodec libx264 -preset slow -tune film -crf 18 \
            -acodec copy  clip-stabilized.mkv

- Пример: извлечение медиа-потоков m3u8 онлайн лайв-стримов

        # Находим ссылки на m3u8 - н-р через браузер - консоль разработчика - вкладка Networking

        # скачивание по ссылке
        ffmpeg -i http://...playlist.m3u8 -c copy -bsf:a aac_adtstoasc out.mp4 
        # некоторые предлагают скачивать в mkv и не конвертировать аудио бит-поток
        ffmpeg -i http://...playlist.m3u8 -c copy out.mkv 
        # скачивание по сохранённому m3u8 файлу
        ffmpeg -protocol_whitelist file,http,https,tcp,tls -allowed_extensions ALL -i input.m3u8 -bsf:a aac_adtstoasc -c copy out.mp4 

        # скачивание аудио дорожек и субтитров
        ffmpeg -i http://...playlist.m3u8 -c copy out.m4a # AAC audio
        ffmpeg -i http://...subs.srt subs.srt

<a name="recipes-userapp-image"></a>
### Обработка Изображений

- RawTherapee - GUI-програма для обработки RAW изображений
- GIMP - редактор изображений общего назначения

        # Для доступа к актуальной версии и плагинам на любом дистр-е лучше использовать Flatpak:
        
        flatpak install https://flathub.org/repo/appstream/org.gimp.GIMP.flatpakref
        flatpak search org.gimp.GIMP.Plugin

- Krita - редактор изображений общего назначения


- imagemagick - утилиты (в тч консольные) для преобразования изображений

        # конвертация в сжатый формат для снижения размера
        convert big.png smaller.jpg 

        # сильное снижение размера засчет уменьшения качества на 25%
        # изменение качества маленького изображения может увеличить размер ввиду оверхеда
        convert img.jpg -quality 85% cimg.jpg 

        # установить ширину изображения в 1024px, сохраняя соотношение сторон
        convert img.jp -resize 1024x cimg.jpg 

<a name="recipes-userapp-etc"></a>
### Разное

- Программы для восстановления удалённых файлов
    `testdisk` - основная цель - восстановление потерянных разделов и не-загружающихся дисков
    `photorec` - идет вместе с `testdisk`. Восстановление изображений, видео, документов и архивов с жестких и оптических дисков, памяти цифровых камер
    `ext4magic` - восстановление стёртых/перезаписанных файлов c файловых систем ext3/etx4

- `lm_sensors` - считывание данных с различных датчиков - температура, напряжение, и тд.
    - Использование:

            sudo sensors-detect # определяем, какие модули ядра нужно загрузить
            sensors # получаем показания датчиков

    - GUI фронт-энд:
        - KDE Plasma: Thermal Monitor applet
        - XFCE4: Sensors panel plugin
        - Gnome: Freon

- `stress` - дать нагрузку на процессор/память
    - `stress --cpu 2` - создать два потока вычисляющих sqrt()

<a name="etc"></a>
# Разное o Linux

<a name="etc-filesystem"></a>
## Cтруктура Файловой Системы

- Документация
    - `man 7 hier` - описание иерархии файловой системы Linux
        - Этот документ впервые появился в 7-ом издании Unix (1979)
        - Точного совпадения со структурой реальных ФС ожидать не стоит
    - `man 7 file-hierarchy` - иерархии ФС на дистрибутивах, основанных на Systemd
        - Конкретные дистрибутивы могут отклоняться от этого документа
    - Спецификация XDG Base Directory - https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
        - Используется основными DE

- Расположение приложений
    - `/usr/bin` - основная директория для исполняемых команд, доступных для всех пользователей
        - `/bin`, `/sbin`, `/usr/sbin` - символьные ссылки на /usr/bin, нужны для совместимости
    - `/usr/lib` - статические библиотеки, внутренние исполняемые файлы, и тд
        - Обычно `/lib` и `/lib64` - символьные ссылки на `/usr/lib` для совместимости
    - `/usr/lib/arch-id` - $libdir, динамические библиотеки
        - В некоторых дистр-ах `/lib64` - ссылка на $libdir
    - `/usr/share` - общие ресурсы - документация, шрифты, и тд
        - `/usr/share/applications` - ярлыки (Desktop-Entry) приложений
        - `/usr/share/icons` - изображения-иконки 
    - `/etc` - конфиги для всех пользователей
    - `/var` - изменяемые данные приложений, сохраняющиеся при перезагрузке
    - `/opt` - пред-скомпилированные дополнительные пакеты, доступные для всех пользователей
    - `/usr/local` - программы, специфичные для машины, в частности собранные из Makefile-ов
        - Отражает `/usr/{bin,lib,share}` структуру
    - `~/.local` - аналог `/usr`, локальный для пользователя
    - `~/.config` - конфиги, локальные для пользователя
    - `~/.cache` - долговременный кэш приложений, локальный для пользователя
    - `~/.var` - `flatpak` использует это как аналог /var, локальный для пользователя

- Разные файлы
    - `/etc/os-release` - информация о дистрибутиве
    - Профиль оболочки
        - `/etc/profile` - профиль оболочки активный для всех пользователей
        - `~/.profile` - профиль любой оболочки для текущего пользователя
        - `~/.bash_profile` - профиль Bash для текущего пользователя

<a name="etc-advice"></a>
## Общие Советы

- Способы изучения Linux
    - Установить LFS: http://www.linuxfromscratch.org/lfs/downloads/stable/LFS-BOOK-10.0.pdf
    - Писать утилиты командной строки на чистом C
        - Таким образом можно изучить системные вызовы, часто используемые функции системной библиотеки
        - Для этой же цели можно изучать вывод `strace` и `ltrace`
    - Изучать код ядра
        - Взять случайный файл в `/proc`
            - Понять, что в нем, для чего он
            - Найти исходный код, который создает его
        - Kernel Helloworld: написать модуль ядра, который добавляет файл в `/proc` с каким-то текстом
        - Ядра которые поставляются с дистрибутивами очень большие. Скомпилировать юзабельное ядро меньшего объема.
    - Читать lwn.net
    - Пройти Advanced Bash Scripting Guide с сайта TLDP

- Способ изучения Linux Security
    - Эмулировать сеть с вредоносными и атакуемыми машинами
    - Изучать логи на атакуемых машинах
    - Настраивать сервисы (веб-сервер, файрволл) на атакуемых машинах
    - Изучать трафик (с помощью `tcpdump`, `wireshark`) в этой сети

<a name="etc-references"></a>
## Ссылки

### Исходники Ядра Linux

- Где находятся: https://github.com/torvalds/linux/
- Исходники содержат документацию.
    - Ее также можно читать тут: kernel.org/doc/html/latest
- Руководство по ядру Linux для пользователей и администраторов:
    - https://www.kernel.org/doc/html/latest/admin-guide/index.html
- Имея исходники, документацию можно отрендерить в html и pdf:
    - `make htmldocs`, `make pdfdocs;`

### Разные Онлайн-Ресурсы

- gnu.org - всё о GNU, в тч документация
    - gnu.org/manual/#Software
    - gnu.org/software/bash/manual
- tldp.org - гайды, мануалы по Linux
- linuxfromscratch.org - образовательный проект, посвященнный сборке кастомного Linux
- github.com, gitlab.com - многие проекты с открытым исходным кодом хостятся здесь, в тч код ядра Linux
    - Часто проблемы с приложениями обсуждаются в issues
- wiki.archlinux.org - полезна для любого дистрибутива
    - См. статьи General Recommendations, Security, Improving Performance
- wiki.debian.org - Debian wiki.
- distrowatch.com - новости и статистика различных дистрибутивов
- www.freedesktop.org/wiki - хостинг для проектов с открытым исходным кодом

- Нишевые сайты:
    - gnupg.org/documentation/ - документация Open PGP
    - tools.kali.org/tools-listing - список различных утилит для взлома
    - https://openbenchmarking.org/ - открытые программы для оценки производительности

- Communities and news:
    - reddit.com - много полезных технических сабреддитов, н-р /r/VFIO
    - lwn.net - новости свободного ПО
    - linux.org.ru - большое Русскоязычное сообщество Linux
    - opennet.ru - русскоязычный сайт новостей об открытом ПО
    - blogs.oracle.com - много качественных гайдов об админстрации Linux
    - www.grymoire.com - коллекция текстов o Unix

- QA-Сайты:
    - stackoverflow.com - вопросы от программировании
    - unix.stackexchange.com - вопросы о Unix и Linux
    - serverfault.com - вопросы об администрации IT-систем
    - askubuntu.com - вопросы об Ubuntu
    - security.stackexchange.com - вопросы о безопасности
    - superuser.com - вопросы компьютерным энтузиастам
